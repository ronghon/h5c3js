  捐ECMAScript
  chrome V8 engine
02===============================================================================================
 輸出語句: 
  alert() 警告框(提示框)
  document.write() 於HTML的Body內寫入資料
  console.log()  於chrome瀏覽器內控制台輸出一段內容
03===============================================================================================
  編寫位置
  1.行間
  2.<script>標籤內放於<head>內或</body>前
  3.用<script>外部引入，src連結===>建議使用
04===============================================================================================
  //單行註釋
  /* 多行註釋 */
  1.嚴格區分大小寫
  2.每一條語句以分號;結束
  3.忽略空格和換行
05字面量(常數)和變量==============================================================================
  1.不可改變的值,可以直接使用,但一般不會直接使用
  2.可用變數存放常數,即變數的值可任意改變
  var 聲明變量
  var a=123  a是變數、123是賦值 = 將123賦值給a
06標識符=========================================================================================
  (識別碼ID):可以由我們自主命名的均可稱之為標識符,如變量名、函數名、屬性名...
  1.首字母不能數字,可以是字母、數字、_、$
  2.不是關鍵字、保留字
  3.駝峰命名法:就是當變數名或函式名是由一個或多個單字連結在一起，而構
    成的唯一識別字時，第一個單字以小寫字母開始，第二個單字的首字母大寫
07數據類型(資料類型)==============================================================================
  1.String：字串 ==>使用引號括起來,單雙引均可,但不可混用,輸出時加引號表示字串,未加表示變量
  2.Number：數值
  3.Boolean：布林值
  4.Null 空值
  5.Undefined 未定義 ==>前五種為基本數據類型
  6.Object 物件;對象-->引用數據類型
08number類型======================================================================================
  typeof 變量  檢查變量類型
  Number.MAX_VALUE數值的最大值  Number.MIN_VALUE大於0的最小值
  Infinity 無窮大  Type=number
  NaN Not a number 非數字  Type=number
  在JS中執行浮點數運算時,可能得到一個不精確的結果
09boolean布林值==================================================================================
  true/false 邏輯判斷用
10null===========================================================================================
  null專門用來表示空對象 type=object
  undefined 1.未定義變量 2.未賦值  type=undefined  ==>未定義  
11類型轉換========================================================================================
  指將類型轉換為string、number、boolean 
  number轉string ==>
  1.調用xxx.toString()方法，該方法不會影響原變量，它會將轉換的結果返回，但是注意null and undefined 
    無法使用toString()轉換
  2.調用String(參數)函數,並將被轉換的數據作為參數傳遞給函數
    使用String()函數強制類型轉換時,對Number和Boolean而言是調用toString()方法，但對於Null和Undefined而
    言，就不會調用toString()方法,它會將null直接轉換為"null"、將undefined轉換為"undefined"
12將其他類型轉換為number==========================================================================
 1.調用Number()函數--類型均轉為Number,但值就不一定是原值
   **字串-->數字
     1.如是純數字的字串,則轉成數字
     2.字串中包含非數字,則轉成NaN
     3.字串中如為""空值或"  "包含空格字串,則轉為0
   **boolean-->數字
     1.true -->1
     2.false-->0
   **null---->數字
     null---->0
   **undefined-->數字
     undefined--->NaN
  2.專門用來轉換字串中的數字
    --parseInt()把字串中的有效的整數內容取出來,然後轉換為Number,由左到右判斷是否為數字,遇到非數字時就中止
    --parseFloat()把字串中有效的小數(含整數)取出來  
13二進位、八進位、十六進位=========================================================================
  0x開頭表示16進位,0~9abcdef
  0開頭表示8進位,0~7
  parseInt(a,10) 10表示以10進位方式轉換,8表示8進位方式轉換
14轉Boolean======================================================================================
  使用Boolean()函數
  1.數字-->Boolean 
    除了0和NaN外,其餘均為True
  2.字串-->Boolean
    除了空字串,其他均為True
  3.null和undefined均為false    
  4.object轉換後為True
15運算符(操作符)==================================================================================
  ex:typeof  + - * / 等通過運算符可以對一個或多個值進行運算,並獲取運算結果
     typeof 本身的返回值是string類型
  "+"意義有兩種  1.字串鏈接(先) 任何值與字串相加時,值均會先轉換為字串,然後再執行字串鏈接
                2.數字相加(後)
  a.如對非數字的類型的值進行運算時,會先轉換為數字然後再計算
  b.任何值與NaN相加後均為NaN
    ***隱式類型轉換為String字串方式
    var c=123;
    c=c+""    
  c.透過上述方式可以將任一個數據類型轉換為String
  d.任何值做 - * / 運算時都會先自動轉換為Number類型
  e.可藉由 -0  *1  /1等方式將任何值轉換為Number,其原理與Number()函數一樣(隱式類型轉換)
16一元運算符======================================================================
  對非數字的值轉換為Number,然後再運算
  可對其他數據類型使用+進行轉換為Number,其原理與Number()函數相同(隱式類型轉換)
17自增與自減======================================================================
  自增:使變量在自身基礎上增加1,分兩種a++、++a 變量自增後,原變量值會立即自增1
  無論是a++或是++a 均會立即使原變量的值自增1(對原變量而言作用相同),不同的是a++和++a本身的值不同
  a++本身的值等於自增前的值,console.log(a++)--->變量的原值(先賦值再加加)
  ++a本身的值等於自增後的值,console.log(++a)--->變量的新值(先加加再賦值)
  自減:使變量在自身基礎上減少1,分兩種a--、--a
  a--本身的值等於自減前的值,console.log(a--)--->變量的原值
  --a本身的值等於自減後的值,console.log(--a)--->變量的新值
19三種邏輯運算符1(Boolean)=====================================================================
  !  否 (NOT)--可用來對true進行取反否定, !true=false !!true=true !false=true
        對非Boolean值進行取反時,會先將其轉換為Boolean,然後再取反
        可以對任一數據類型取反兩次,將類型轉換為Boolean(隱式類型轉換),其原理與Boolean()函數相同
        var b="123";
        b=!!b;
  && 且(AND)--[找false],只要第一個值是false,就停止,直接傳回false,只有第一個值為true,再判斷第二個值是否為true 

  || 或(OR)--[找true],只要第一個值是true,就停止,直接傳回true,只有第一個值為false,再判斷第二個值是否為false
20三種邏輯運算符2(非Boolean)=============================================================================
  對非Boolean類型的數據會先轉換為Boolean,然後再運算,並且返回原值
  &&且--->如果兩個值均為True,則返回後面的值---如果第一個值為true,則返回第二個值
      --->如果兩個值中有false,則返回前面的值---如果第一個值為false,則返回第一個值
  ||或(OR)如果第一個值是true,就停止,直接傳回第一個值
          如果第一個值為false,則返回第二個值
21賦值運算符=============================================================================================
  = 賦值:將等號右側的值賦予給等號左邊的變數
  +=       a += 5--->a=a+5                a %= 5--->a=a%5
  -=       a -= 5--->a=a-5                a /= 5--->a=a/5
22關係運算符=============================================================================================
 比較兩個值的大小關係
 非Number數值類型比較-->1.對非數值進行比較時,會先將其轉換為Number再進行比較,但如果兩個均為字串作比較時,不會轉成Number
                         類型而是比較字串中字符的Unicode編碼且是一位一位進行比較===>可以用於英文名字排序
                       2.任何值與NaN比較時,結果均為false
                       3.如果比較兩個字串類型的數字時,一定要轉換類型可以用+號轉為Number,否則會出現不可預期結果
23Unicode=================================================================================================
  在字串中使用轉義字符輸入Unicode編碼 \u四位編碼
  在網頁中使用Unicode編碼&#編碼;  十進制
24相等運算符===============================================================================================
  = 賦值
  ==判斷兩個值是否相等  當使用==作判斷時,如兩個類型不同時,會自動進行類型轉換成相同類型再作比較判斷
  　判斷一個值是否為NaN 可以使用isNaN()函數
  !=不相等 當使用!=作判斷時,如兩個類型不同時,會自動進行類型轉換成相同類型再作比較判斷
  ===全等:用來判斷兩個值是否全等,包含值和類型,即不會自動作類型轉換,如果兩類型不同直接返回false
  !==不全等;用來判斷兩個值是否不全等,和不等類似,不同的是它不會自動作類型轉換,如果兩類型不同直接返回true
25條件運算符(三元(三目)運算符)====================================================================================
  ?:  --->語法: 條件表逹式 ? 語句1 : 語句2 --->先判斷條件表逹式是否成立,若為true(非0),則執行語句1,若為false時,則執行語句2
  判斷最大值 
	  var num1=20,num2=30;
		var max= num1>num2?num1:num2;
		alert(max);
26運算符優先級========================================================================================
	--同時聲明多個變量並同時賦值,可使用逗號,隔開
	JS運算符優先級:與數學優先級相同,先乘除後加減,如遇需優先計算式,可透過()改變優先執行
27語句===============================================================================================
  JS執行時是按照由上到下,由左到右執行,可以使用{}來進行分組,同一{}中語句稱為一組語句,只具分組作用,無其他用途,
  {}中的內容,在外部是完全可見的

28流程控制語句========================================================================================
  用來控制執行流程,使程序可以依據條件選擇執行,區分為三種：
  1.條件判斷語句--又稱if語句
  	可在執行某段語句前進行判斷,如果條件成立才會執行語句,條件不成立則不執行語句
   	 語法1:
    	if(條件表逹式){
           	語句...
    	} 
    if語句在執行時,會先對條件表逹式進行求值判斷,如果條件表逹式的值為true,則執行if後的語句,如果條件表逹式的值為false,則不會執行if後的語句,
    if語句只能控制緊隨其後的那個語句,如果希望if語句可以控制多條語句,則可使用{}組成一組
29if語法2===============================================================================================
   語法2：
 	  if.... else.. 
   	      規則：先判斷條件是否成立，如成立時則執行語句1,如不成立時則執行語句2
   		if(條件){
	  		語句1;   
  		 }
   		else{
   	 		語句2;
   		}

   語法3:
   if ...else if...else...
   	規則：
   1.執行時,由上到下依序對條件進行判斷,如條件符合則執行該語句,且執行後直接結束語句,如未滿足(false)時,則會繼續往下條件檢查,直到滿足為止,，如果所有條件均不滿足時，則執行else後面語句。
   2.else if 可以多個,但最後else只能一個
   	if(條件1){
    	語句1
   	}else if(條件2){
  		語句2
    }else if(條件3){
 		  語句3
    }else{
    	語句4
    }
30===============================================================================================================   
  prompt()可彈出一帶文本的提示框,以利用戶在文本框內輸入文字,該函數需一個字符串作為參數提示用戶輸入內容,用戶輸入的內容將會作為
  函數的返回值返回,可定義一個變量接收該內容
  var score=prompt("請輸入成績:")

33===============================================================================================================
  2.條件分支語句--也叫switch語句
    語法:switch(條件表逹式){
          case 表逹式:
            	語句1...
							break;
          case 表逹式:
            	語句2...
							break;
          case 表逹式:
            	語句3...
							break;
          default:  
            	語句4...
							break;
        }  
    執行流程:switch...case...語句在執行時會依次將case後表逹式的值和switch後條件表達式的值進行"全等"比較
                            如果比較結果為True,則執行case後之所有語句,因此於各個語句後加入break;(中斷執行退出switch)
                            如果為false,則檢查下一個case後之表逹式的值,以此類推。
           default表示所有條件均不滿足false時執行語句   
  ****switch語句與if語句功能上重覆,意即使用switch可以實現if的功能,反之,if也可以實現switch功能,一般表示兩個分支或者嵌套比較少的
			分支時使用if..else ,如果分支較多情況,則使用switch                    
35循環語句===========================================================================================================
  3.循環語句:通過循環語句可以反復多次執行一段代碼
  	a.while循環--
   	語法:while(條件表逹式){
          	  語句
        	}
   	規則:1.先對條件求值判斷,如為true,則執行語句,再判斷再執行語句,以此類推,如為fasle時則終止循環
        2.如將條件表逹式寫死為true的循環稱為死循環;該循環不會停止,除非關閉瀏覽器來終止循環或加入break中斷

			***創建一個循環三個要件：
			1.初始化變量:i=0
			2.條件判斷:i<10
			3.自增:i++
	
  	b. do...while循環...
		 語法:
  		do {
					語句
  		}
  		while(條件表逹式);
	規則:執行時,會先執行循環體一次,再執行判斷,如果為true則繼續執行語句,然後再判斷-->執行語-->判斷,以此類推
       如果為false時,則中止循環
  **while...與do..while...兩種語法功能類似,但不同的是while...是先條件判斷再執行循環體,而do...while...則先執行一次再條件判斷
    do...while...可保證循環體執行乙次,但while不能
37for循環=======================================================================================================
  	c.語法:for(初始化;條件;自增){
       		語句
       		}
	規則:1.先執行初始化變量(只會執行乙次)
        2.條件表逹式判斷,如為true,則執行語句
        3.執行自增
        4.判斷條件是否仍為true,則繼續執行語句,如為false,則終止循環
39for循環嵌套===================================================================================================
  1.通過for循環輸出一個圖形
  2.九九乘法表練習
  3.取出1-100質數
44break and continue=========================================================================================
  1.break關鍵字可以用來退出switch或循環語句,但不可在if語句中使用break和continue
  2.break會立即終止離它最近的循環語句,如需終止外層循環語句,則可以為循環語句創建一個 label名字:循環語句 來指定外層循環語句
    使用break語句時,可以在break後加上label名字,如此即可終止指定的循環,而不是最近的循環語句
  3.continue可以用來跳過當次循環,默認只會對離它最近的循環起作用,如需跳過外層循環,則與break相同,創建一個label名字:循環語句
****測試性能提昇方法********************
  1.在程序執行前,開啟計時器--->console.time("計時器名字")可以用來開啟一個計時器,它需要一個字串作為參數,以作為計時器的標識
                停止計時器--->console.timeEnd("計時器名字")
  2.檢查j<i 值,僅需到根號i值即可,後面的值可省略
    根號i-->Math.sqrt(i)使用Math.sqrt()對一個數進行開根號
46object=========================================================================================
基本數據類型的不足：
　 1.基本數據類型均是單一值,ex:"hello" 123 true ,值與值之間没有任何聯繫。
  2.如果使用基本數據類型的數據,所創建的變量均是獨立的,不能成為一個整體。
object對象(物件):屬於一種複合數據類型,在對象中可保存多個不同數據類型的屬性,如同一個容器、袋子一般
分類:
 1.內建對象:由ES標準中定義的對象,在任何ES的實現中均可使用  ex: Math String Number function.....
 2.宿主對象：由JS的運行環境提供的對象,目前主要指瀏覽器提供的對象 ex：BOM DOM
 3.自定義對象:由開發人員自行創建的對象-->三者之中最難的

47創建對象方式1:使用構造函數========================================================================
  創建對象(物件object)：
   -使用new關鍵字調用的函數,是構造函數constructor:專門用來創建自定義對象的函數
  var obj = new Object();  //使用typeof檢查時會返回類型為object
  在對象中保存的值稱為屬性,
   1.向對象添加屬性
		-語法:對象.屬性名=屬性值;
    ex:  obj.name = "王大海";
         obj.sex = "男";
         obj.age = 18;....... name sex age 均為obj的屬性
   2.讀取對象中的屬性：
		-語法：對象.屬性名  ex: consloe.log(obj.name);如果讀取對象中没有該屬性時,不會報錯而是返回undefined
   3.修改對象的屬性值:
		-語法:對象.屬性名=新值
   4.刪除對象屬性:  
		-語法:delete 對象.屬性名

48屬性名和屬性值==================================================================================
  1.屬性名:對象的屬性名不強制要求遵守標識符規範,任何名字均可使用,但儘量按照標識符規範命名,如果使用特殊的屬
          性名,不可使用.的方式操作,改用中括號-->[""]
        語法: 對象["屬性名"] = 屬性值  讀取時也需使用這種方式
        使用中括號[]模式操作屬性,更加靈活,例如可在[]中直接傳遞一個變量,如此變量值多少就會讀取那個屬性
  2.屬性值:JS對象的屬性值可以是任意的數據類型,甚至也可以是一個對象
      in 運算符-->用來檢查某個對象中是否含有指定的屬性時使用in運算符,如有則返回true,如無則返回false
      語法: "屬性名" in 對象 ex:console.log("test" in obj);

49基本和引用數據類型===============================================================================
  數據類型區分兩大類:
  一.基本數據類型:String Number Boolean Null Undefined
  二.引用數據類型:Object 
  1.js的變量均是保存棧內存中。 基本數據類型儲存的是值,而引用數據類型儲存的是引用地址。
  2.基本數據類型的值直接在(棧內存Stack)中存儲,值與值之間是獨立存在,修改一個變量的值不會影響其他變量的值
  3.對象是保存到(堆內存Heap),每創建一個新的對象,就會在堆內存中開闢出一個新的空間,而變量保存的是對象的內存地址(對象的引用),
          如果兩個變量保存的是同一個對象引用,當其中一個變量修改屬性時,另一個也會受到影響
  4.當比較兩個基本數據類型的值時,就是直接比較值是否相等。
  5.當比較兩個引用數據類型時,它是比較對象的內存地址,如果兩個對象一模一樣,但地址不同時,它也會返回false,意即屬性名和屬性值不作比較
  	如同DNA一般,雙胞胎雖DNA可能完全相同,但他們代表兩個人(對象)

50創建對象方式2:使用對象字面量=====================================================================
  創建對象的方式:
  1.使用構造函數 var obj= new Object()
  2.使用對象字面量,ex var obj={} ,或可在創建對象時,直接指定對象的屬性,屬性名可加引號或不加,建議不加,但
    使用特殊名字時,則要加引號
    語法: {屬性名1:屬性值1,屬性名2:屬性值2,屬性名3:屬性值3...}名和值之間使用:連結,多個屬性之間以,逗號隔開,最後
                  一個已無其他屬性了,就不用再加,逗號
    ex:  var obj = {name:"王大同",sex:"男",age:20};-->創建對象時同時指定屬性 or
         var obj = {
             name:"王大同",
             sex:"男",
             age:20,
             test:{name:"沙和尚"}-->屬性值也可以是對象或函數
            };

51函數簡介========================================================================================
  1.函數也是對象之一,具有普通對象的功能(可添加屬性...),但函數功能較強大,還可以封裝一些功能(代碼),在需要時可
		執行這些功能(代碼)--調用函數()
  2.使用typeof檢查函數的數據類型時會返回function
  創建函數方式:
  1.使用構建函數創建一個函數:(很少用此方法)-->1.使用new關鍵字 2.Function首字母大寫
    var fun = new Function()  //可將要封裝的代碼以字符串形式傳遞給構造函數,封裝到函數中的代碼不會立即執行
		,只有在調用時才執行
    **調用函數語法：函數對象()  調用函數時,封裝的代碼會按照順序執行
  2.使用 "函數聲明" 創建一個函數：
    語法: function 函數名([形參1,形參2....形參n]){
              語句...
          }
    調用: 函數名()  
  3.使用 "函數表逹式" 創建一個匿名函數,並將匿名函數對象賦值給一個變量
    var 變量 = function([形參1,形參2....形參n]){
          語句...
        }; <---如同宣告變量一般,最後記得加上;
    ex: var fun3 = function(){    //聲明一個匿名函數
        console.log("這是我的第二個函數");
        };
      調用 fun3()

52函數的參數========================================================================================
可在函數的()中指定一個或多個形參(形式參數,未指定值),多個形參之間以逗號,隔開,聲明形參就相當於函數內部聲明對應的變量,但並未賦值,在調用函數時,可在()中指定實參(實際參數),實參將會賦值給函數中對應的形參,調用時瀏覽器不會檢查實參類型,因此注意可能會接收到非法參數,必要時需對實參類型進行檢查,調用時瀏覽器也不會檢查實參的數量,多餘的實參不會被賦值,實參少於形參者,則没有對應的形參,將產生undefined結果
  實參注意事項:
	1.調用時瀏覽器不會檢查實參類型-->所以必要時要檢查實參的數據類型
	2.不會檢查實參數量-->多餘部份不會被賦值
	3.實參可以是任意數據類型

53函數返回值=========================================================================================
  使用return來設置函數返回值:
  語法: return 值    
  1.return後的值將會作為函數的執行結果,因此,可定義一個變量來接收執行結果;
  2.在函數中return後的語句都不會執行	-->函數已將執行結果返回,所以return後的語句都不會再被執行
  3.return語句後不加任何值,或者不寫return時,則函數調用結果將返回undefined
  4.return後的值可以是任何類型(包含運算式、判斷式...)
54================================================================================================
  1.實參可以昰任意的數據類型,也可以是對象,當參數過多時,可將參數封裝到一個對象中,再通過對象傳遞
  2.實參也可以是一個函數
55函數返回值與break ==============================================================
	使用break可以退出當前的循環
	使用continue可以跳過當次循環
	使用return可以結束整個函數
返回值可以任意的數據類型,包括運算式,判斷式....也可以是一個對象和函數-->對象能做的事,函數也都能做	

57Js方法==============================	==============================================================
	1.對象的屬性值可以是任何數據類型,也可以函數
	2.如果函數作為對象的屬性保存時,則稱這個函數是這個對象的方法,
		調用函數則稱為調用這個對象名的方法,但是它只是名稱上的區別,没有本質上的差別
	==枚舉對象中的屬性==
	使用for...in 語句
	語法: for(var 變量 in 對象){
		}
	for...in語句  對象中有幾個屬性,循環體就會執行幾次,每次執行時,會將對象中的一個屬性的名字賦值給變量
	每次執行時,會將對象中的一個屬性的名字賦值給變量,這個變量就是屬性名,如要取得屬性值是則可以用
	-->對象[變量]

58全局作用域(scope)=========================================================================================
	 作用域指一個變量的作用範圍,區分為兩種:全局作用域及局部(函數)作用域
	 1.全局作用域:
	 	a.直接編寫在script標籤中的JS代碼,都在全局作用域中
	 	b.在頁面打開時創建,在頁面關閉時銷毀
	 	c.在全局作用域中有一個全局對象window,它代表的是瀏覽器的窗口,它由瀏覽器創建,可直接使用ex:console.log(window);
	 	d.全局對象window用途:
     (1)在全局作用域中所創建的任何變量均會作為window對象的屬性保存。
     (2)創建的函數也會作為window對象的方法保存 ex:window.alert("hello")
	 	e.全局作用域中的變量都是全局變量,在頁面的任意地方均可以訪問的到
	 	
	2.變量的聲明提前===
	 	1.使用var關鍵字聲明的變量,會在所有的代碼執行之前被聲明(但尚未賦值),但聲明變量時不使用var關鍵字,則變量不會被聲明提前,會報錯
	 	
	3.函數的聲明提前===
	 	1.函數聲明會被提前創建:使用函聲明方式創建的函數 function 函數名(){},它會在所有的代碼執行前就被創建,因此可以在函數聲明前調用函數
	 	2.函數表逹式不會被提前創建:使用函數表逹式創建的函數 var fun=function(){},它不會被聲明提前,所以不能在聲明前調用函數
	 
59函數(函數)作用域======================================================================================================
	1.調用函數時創建函數作用域,函數執行完畢後,函數作用域銷毀
	2.每調用一次函數就會創建一個新的函數作用域,他們之間是互相獨立的
	3.在函數作用域中可以訪問到全局作用域的變量,而全局作用域中無法訪問到函數作用域的變量(由內往外找得到,但由外往內看不到)
	4.當在函數作用域操作一個變量時,它會先在自身作用域中尋找,如果有就直接使用,如果没有則向上一級作用域尋找,直到找到全局作用域,如果全
		局作用域中也没有找到,則會報錯未定義
	5.在函數中如要直接使用全局變量,可以使用window對象
	6.在函數作用域中也有聲明提前的特性,使用var關鍵字聲明的變量,會在函數中所有的代碼執行前被聲明
	7.函數聲明也會在函數中所有代碼執行前被聲明
	8.在函數中,不使用var聲明的變量都會成為全局變量
    function fun(){
      console.log(a);
      a=10;
    }
    fun();
	9.定義形參就相當於在函數作用域中聲明了一個變量
    function fun(e){ //定義變量e但未賦
      alert(e);      //undefined
    }
    fun();未賦值
60debug===========================================================================================	
61this===================================================================================================================
	1.瀏覽器在調用函數時每次都會向函數內部傳遞一個隠含參數this,它指向的是函數執行的上下文對象
	2.根據函數調用方式不同,this會指向不同的對象
		- 以函數的形式調用時,this永遠都是window
		- 以方法的形式調用時,this就是調用方法的對象
		
63使用工廠方法(Factory Method)創建對象========================================================================================
	==利用工廠方法使一個類別的實例化延遲到其子類別==
	- 透過工廠方法可大批量的創建對象
		1.創建一個新的對象-->使用new關鍵字 new Object()
		2.向對象中添加屬性
		3.將新的對象返回-->用return返回值
	- 使用工廠方法創建的對象,使用的構造函數都是屬於object類型,會導致無法區分多種不同類型的對象

	==構造函數==
	  構造函數,專門用來創建自定義對象,它也是一個普通函數,創建方式與普通函數没有區別,不同的是
	  1.構造函數習慣上首字母大寫
	  2.調用方式的不同,普通函數是直接調用,而構造函數需在調用時加上new關鍵字
	  3.構造函數執行流程:
			a.調用時會立即創建一個新的對象
			b.將新建的對象設置為函數中的this,在構造函數中可以使用this來引用新建的對象
			c.逐行執行函數中的代碼
			d.將新建的對象作為返回值返回,不用設定return返回值
	  4.使用同一個構造函數創建的對象,我們稱為一類對象,也將一個構造函數稱為一個類,
		  透過構造函數所創建的對象,稱為該類(構造函數)的實例
	  5.使用instanceof 可以檢查對象是否是一個類的實例==>判斷實例的類型
		語法: 對象 instanceof 構造函數  ==> 如果是,則返回true,如果不是,則返回false
	- 所有的對象都是Object的後代,所以任何對象使用instanceof檢查時都會返回true

	==this使用情況==
		1.當以函數的形式調用時,this永遠都是window
		2.當以方法的形式調用時,誰調用方法this就是誰
		3.當以構造函數的形式調用時,this就是新創建的那個對象

65構造函數修改=========================================================================================
		1.在構造函數中為每個對象添加fun方法,
		2.構造函數每執行乙次就會創建一個新的fun方法,也就是所有實例的fun方法是唯一且獨立的,但這些方法其實都是一模一樣的,
		3.需將它轉化為所有對象共享的方法,將函數定義在全局作用域中,並將函數名賦予給fun
	
66原型對象=============================================================================================
		將fun方法在全局作用域中定義，產生另外的問題：1.污染了全局作用域的命名空間2.多人開發中較不安全==>新概念"原型"
		==原型對象==
			原型對象屬性prototype,創建函數時由瀏覽器自動向函數中添加prototype和地址並指向原型對象
			我們所創建的每一個函數,瀏覽器都會向函數中添加一個屬性prototype,這個屬性對應著一個對象,而將這個對象稱為原型對象
			如果函數作為普通函數調用時,此一prototype没有任何作用,但當函數以構造函數的形式調用時,它所創建的對象中都會有一個
			隠含的屬性指向該構造函數的原型對象,我們可以通過__proto__來查詢該屬性,  
70內建對象-數組簡介==============================================================================================
	1.數組(Array)也是對象,與普通對象功能類似,不同的是普通對象是使用字符串作為屬性名,數組使用數字作為索引操作元素
	2.索引(index):從0開始的整數就是索引,數組的存儲性能較普通對象好,在開發中我們經常使用數組來存儲一些數據
	3.創建數組對象:	  var arr = new Array(); 使用typeof 返回值object
	4.向數組中添加元素:
	  語法: 數組[索引]=值   var arr[0]=10;  從0開始
	5.讀取數組中元素  語法: 數組[索引],如果讀取不存在的索引,它不會報錯而是返回undefined
	6.獲取數組長度(元素個數),可以使用length屬性,
	  語法: 數組.length,
		(1)對於連續的數組,可使用length獲取數組的長度(元素個數)
		(2)對於非連續的數組,它會獲取到數組最大索引+1 ex var arr[10]=30-->length=10+1=11;儘量不要創建非連續數組
	7.修改length,如果修改的length大於原長度,則多出來部份會空出來(以逗號隔開),如果小於原長度,則多出的元素會被刪除,因此
		可利用此一特性來刪除元素	
	8.向數組最後一個位置添加元素: 語法:數組[數組.length]=值    ex: arr(arr.length)=10;

71使用字面量創建數組================================================================================
	1.使用字面量創建數組,語法:var arr=[],可以在創建時就指定數組中的元素,var arr=[1,2,3,4,6,10];
	2.使用構造函數創建數組也可以同時添加元素,將要添加的元素作為構造函數的參數傳遞,元素之間以,逗號隔開
	  ex: var arr= new array(10,20,30)
	3.但是只創建一個元素時,使用構造函數代表創建一個長度為值的數組,而使用字面量表示創建的是一個元素
	  var arr= new array(10)-->表示創建一個長度為10的數組 arr[0]=''空值
	  var arr[10]-->表示創建一個元素為10的數組 arr[0]=10
	4.數組中的元素可以是任意的數據類型,也可以是對象,函數或數組(二維數組)

72數組的方法(一)=========================================================================================
	push()可向數組的末尾添加一個或多個元素,並返回數組的新長度,可以將要添加的元素作為方法的參數傳遞,如此這些元素將會自動
	      數組的末尾,並將數組新的長度作為返回值返回
	pop()可刪除數組最後一個元素,並將被刪除的元素作為返回值返回
	unshift()可向數組開頭添加一個或多個元素並返回新的數組長度,向開頭插入元素後,其他元素的索引會依次調整
	shift()可刪除數組開頭第一個元素,並將被刪除的元素作為返回值返回

73數組的遍歷=============================================================================================
	所謂遍歷數組,就是將數組中所有元素都取出來,
	1.利用for循環
		for(var i=0;i<arr.length;i++){
			console.log(arr[i]);	
		}
	2.利用for....in
		for(index in object){
			console.log(arr[index]);
		}
	
75forEach=============================================================================================
	一般使用for循環遍歷數組,JS中提供一forEach方法來遍歷數組
	forEach()
	1.IE8以上支持,IE8(含)以下改以for循環來遍歷 
	2.需要一個函數作為參數,這個函數由我們創建但不由我們調用(由瀏覽器調用),稱之為回調函數
	3.數組中有幾個元素函數就會執行幾次,每次執行時,瀏覽器會將遍歷到的元素,以實參的形式傳遞進來,我們可以定義形參來讀取這些內容
	4.瀏覽器會在回調函數中傳遞三個參數,
		第一參數就是當前正在遍歷的元素-->value
		第二參數就是當前正在遍歷的元素索引-->index
		第三參數就是正在遍歷的數組-->obj
	arr.forEach(function(value,index,obj){
		console.log(value);
	})
	
	
76slice和splice============================================================================
	slice()可以用來從數組中提取指定元素(start,end),該方法不會改變元素數組,而是將截取到的元素封裝到一個新數組中返回
	參數:
	1.截取開始的位置索引,包含開始索引
	2.截取結束的位置索引,不包含結束索引
	 - 第二個參數可以省略不寫,則會截取開始索引之後的所有元素
	 - 索引可以傳一個負值,則表示從後往前計算,-1 倒數最後一個 -2 倒數第二個
	 
	splice()多功能方法-->可以用來刪除數組中指定的元素、替換元素、插入元素
	1.使用splice()會影響到原數組,會將指定元素從原數組中刪除,並將被刪除的元素作為返回值返回
	2.參數:
		第一個,表示開始位置索引
		第二個,表示欲刪除的數量
		第三個及以後,可以傳遞新的元素,並自動插入到開始位置索引

78數組剩餘方法================================================================================
	concat()可以連接兩個或多個數組,並將新的數組返回,該方法不會對原數組產生影響,而會以返回值
	
	join()該方法可以將數組轉換為一個字符串,該方法不會對原數組產生影響,而是將轉換後的字符串作為結果返回
		在join()可指定一個字符串作為參數,這個字符串將會成為數組中元素的連接符,如果不指定連接符,則默認
		使用,逗號為連接符
	reverse()該方法用來反轉數組順序(前面的去後面,後面的到前面來),該方法會直接修改原數組
	sort()用來對數組中的元素進行排序,會影響原數組順序,默認依照unicode編碼進行排序,即使純數字也會依
	unicode	編碼排序,可藉由在()中添加一個回調函數來指定排序規則
	arr.sort(function(a,b)){
		return a-b ;//升序排列
		return b-a ;//降序排列
	}
	回調函數中需要定義兩個形參,瀏覽器將會分別使用數組中的元素作為實參去調用回調函數,使用那個元素調用不確
	定,但是肯定的是,在數組中 a一定在b前面,瀏覽器會根據回調函數的返回值來決定元素的順序
		- 如果返回一個大於0的值,則元素會交換位置
		- 如果返回一個小於0的值,則元素位置不變
		- 如果返回一個0,則兩個元素相等,也不會交換位置。
		
79函數的call()和apply()方法======================================================================================
	call()和apply()這兩個方法都是函數對象的方法,需通過函數對象來調用,當對函數調用call()和apply()時都會調用函數執行,
	在調用call()和apply()時可以將一個對象指定為第一個參數,此時這個對象將會成為函數執行的this
	call()方法可以將實參在對象之後依次傳遞ex fun.call(obj,2,3);
	apply()方法需要將實參封裝到一個數組中統一傳遞ex fun.apply(obj,[2,3]);
	
		function fun(){
			alert("hello");
		}
		var obj={name:"王一"};
	fun();
	fun.call();
	fun.apply();上述三種均為函數調用方法,使函數執行 
	
	總結this情況======
	1.以函數的形式調用時,this永遠都是window
	2.以方法的形式調用時,this是調用方法的對象
	3.以構造函數的形式調用時,this是新創建的那個對象
	4.使用call和apply調用時,this是指定的那個對象

80arguments========================================================================================================
	在函數調用時,瀏覽器每次都會傳遞進兩個隠含的參數
		1.函數的上下文對象this
		2.封裝實參的對象arguments
			- arguments是一個類數組對象,它也可以通過索引來操作數據,也可以獲取長度,在調用函數時,我們所傳遞的實參都會封裝到arguments中保存
			- arguments.length可以用來獲取實參的長度(數量)
			- 我們即使不定義實參,也可以通過arrguments來使用實參,只不過比較不方便
			  arguments[0]表示第一個實參
			  arguments[1]表示第二個實參
			
		
			
	
84字符串方法=============================================================================================
	字符串對象在底層字符串是以字符數組形式保存的,可以使用length來獲取字符串的長度
	var str="hello"-->["h","e","l","l","o"]
	var a=str.length(1);-->e
	1.charAt()可以返回字符串指定位置的字符,根據索引可以獲取指定的字符
	2.charCodeAt()獲取指定位字符的unicode字符編碼
	3.String.fromCharCode()可根據字符編碼去獲取字符(需透過構造函數String調用)
	4.concat()可用來連接兩個或多個字符串,作用和"+"相同
	5.indexOf()可用來檢索一個字符串中是否有指定內容,如果字符串中含有該內容,則會返回第一次出現的索引,如無指定字符則返回-1,可在第二個參數中指定開始查找的位置
	6.lastIndexOf()用法與indexOf()相同,不同的是由後面往前找
	7.slice()可從字符串中截取指定的內容,不會影響原字符串,並將截取到內容返回
		參數(start,end)
			第一個,開始位置的索引(包含開始位置)
			第二個,結束位置的索引(不包含結束位置)
			如果省略第二個參數,則會截取到後面所有的字符串,也可傳遞負數作為參數,則會從後面開始計算起
	8.substring()可用來截取一個字符串,與slice()類似,不同的是這個方法不接受負值,如傳負值,則默認使用0,且它會自動調整參數的位置,如第二個參數小於第一個,則自動交換
	9.substr()用來截取字符串
		參數:
		第一個代表截取位置開始的索引
		第二個代表截取的長度
	10.split()可將一個字符串拆分成一個數組,
		參數:需要一個字符串作為參數,並根據字符串去拆分成數組 ex str.split(",")
	
85正則表逹式==============================================================================================
  是一個對象,用於定義一些字符串的規則,計算機可以根據正則表逹式來檢查字符串是符合規則,獲取將字符串中符合規則的
  內容提取出來

  方式一、使用構造函數創建正則表逹式對象==>較具彈性靈活運用
    var 變量 = new RegExp("正則表逹式","匹配模式");匹配模式i-->忽略大小寫, g-->全局匹配模
	
  var reg =new RegExp("a");//定義一個正則表逹式用來檢查一個字符串中是否含有"a"(區分大小寫) 
		在構造函數中可以傳遞一個匹配模式作為第二參數,可以是 i --> 忽略大小寫	g-->全局匹配模		 
	-使用typeof檢查正則對象類型,會返回object
	-正則表逹式的方法:
    test()  使用這個方法可以用來檢查一個字符串是否符合正則表逹式的規則,如果符合則返回true,否則返回false

86正則表逹式2===============================================================================================
	方式二、使用字面量創建正則表逹式==>較簡單但欠缺彈性
		語法: var 變量 = /正則表逹式/匹配模式
		
		使用 | 表示或者的意思 ex:  var reg =/a|b|C/
				[]也是表示"或"  ex: var reg = /[abc]/
				[a-z]表示任意小寫字母
				[A-Z]表示任意大寫字母
				[A-z]表示所有英文字母
				[^ab]使用^表示除了...以外   [^0-9]除了數字以外
				[0-9]任意數字
				
87字符串與正則相關方法===============================================================================================
	1.split()可將一個字符串拆分成一個數組
		傳遞一個正則表逹式作為參數,則可根據正則表逹式拆分字符串,這個方法即使不指定全局匹配,也會全都拆分	
	2.search()可搜索字符串中是否含有指定內容,如果搜索到指定內容,則會返回第一次出現的索引值,如果没有則返回-1
	  它可以接受一個正則表逹式作為參數,再依據規則檢索字符串,只會查找到第一個,即使設置全局匹配
	3.match()
		1.可以根據正則表逹式,從一個字符串中將符合條件的內容提取出來,
		2.默認match()只會找到第一個符合要求的內容,找到以後就停止檢索,
		3.可以為一個正則表逹式設置多個匹配模式且順序無所謂
		4.會將匹配到的內容封裝到一個數組中返回,即使只查詢到一個結果
		5.可來檢查用戶輸入的電子郵件信箱是否正確
	4.replace()可將字符串中指定內容替換為新的內容
		參數(被替換的內容,新內容),默認只會替換第一個,可用正則表逹式解決
  


