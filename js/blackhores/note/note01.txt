21數據類型簡介==
	-javascript是一種弱類型語言,意味著不用提前聲明變量的類型,在程序運行過程中,根據等號右邊的值的類型來確認。
	-js屬於動態語,相同的變量可作不同類型的轉換,以最後一個賦值為主。
22數據類型分類==
	基本數據類型:Number、Boolean、String、Null、Underfined
	複合數據類型:Object
23 isNaN==
	isNaN()-->用來判斷值是否為非數字
						true:是非數字
						false:是數字
24字符串String==
	-加單引號或雙引號者,嵌套時外雙內單
	-轉義字符 用\開頭ex:\n:換行  \\斜摃\  \b空格  \t tab縮進
26字符串長度與拼接==
	-檢查並獲取字符串長度時,使用length屬性
	-字符串拼接:任何數據類型與字符串相加時為字符串拼接
30獲取數據類型==
	-使用typeof檢查數據類型
	-使用prompt()取出來的值是字符串類型
31字面量==
	字面量:固定值的表示法
32數據類型轉換1==
  -轉成字符串類型
	toString()-->變量.toString()
	String()-->函數  String(變量)
	加號字符串拼接-->變量+''(空字符串)-->隱式轉換
33 34數據類型轉換2==  
  -轉成數值類型	
	parseInt(string)函數-->將string類型轉成整數數值類型(取整,不會四捨五入進位,由左往右取,遇非數值時就停止)
	parseFloat(string)函數-->將string類型轉成整數或浮點數數值類型(取整或取小數點)
	Number()強制轉換函函數-->將string類型轉成數值類型
	js隠式轉換(- * /)-->利用運算式進行隠式轉換為數值 (-0 *1 /1)

37轉成Boolean==
	'' 0 NaN null undefind -->均轉成false
	其餘值均轉成true
42運算符(操作符)==
	-包括算術  比較  邏輯  賦值  遞增(減)
	-不要直接使用浮點數作為比較判斷是否相等-->浮點數會有精確度問題
43 44 45 46 47表逹式與返回值==
	-表逹式:由數字,運算符,變量等組成的式子
	-將右邉表逹式運算結果返回給左邉的變量,所有表逹式均會有一個結果返回給我們,稱之為返回值
	++變量-->前置自增(先自增,後返回值)
	變量++-->後置自增(先返回原值,後自增)
	(前置自增和後置自增如果單獨使用時,效果相同)
48比較(關係)運算符==
	-會返回布林值(true false)
	 '='賦值,將右邊給左邊	
	 '=='判斷是否相等-->會轉換類型,只要求值是否相等
	 '==='全等-->不會轉換類型,包含值和類型是否全都相同
49邏輯運算符==
	-也是會返回布林值(true false)
	&&'與'-->and-->找false(只要為第一個表逹式返回值為false時即返回false,如為true再進行第二個表逹式判斷) 
	||'或'-->or -->找true	(只要為第一個表逹式返回值為true時即返回true,如為false再進行第二個表逹式判斷)
	! '非'-->not-->取反
51 52短路運算(邏輯中斷)==
	邏輯中斷會影響程序運行結果
	&&(找false)
	表逹式1 && 表逹式2
	如果表逹式1為true,則返回表逹式2
	如果表逹式1為false,則返回表逹式1(表逹式2不會再進行判斷)
	||(找true)
	表逹式1 || 表逹式2
	如果表逹式1為true,則返回表逹式1(表逹式2不會再進行判斷)
	如果表逹式1為false,則返回表逹式2
55流程控制==
	區分為三種-順序結構,分支結構,循環結構
	分支結構-if語句,switch語句
	if (條件表逹式){
		執行語句
	}    
	條件為true-->執行語句
	條件為false-->不執行語句,並跳出if執行後面的代碼
59if else語句雙分支(二選一)==
	if (條件表逹式){
		執行語句1
	} else{
		執行語句2	
	}
	如果條件表逹式為true,則執行語句1,如為false則執行語句2,在這個雙分支語句最終只能有一個語句被執行
60潤年與平年判斷==
	能被4整除且不能整除100者為潤年,或能被400整除的就是潤年
	var year =prompt('請輸入判斷年份');
	if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0){
		alert('你輸入的年份是潤年');		
	} else{
		alert('你輸入的年份是平年');
	}
61if else if(多分支語句)(多選1)==
	多分支語句,就是利用多個條件來選擇不同的語句執行,為多選1的過程
	if (條件表逹式1){
		執行語句1
	}else if(條件表逹式2) {
		執行語句2
	}else if(條件表逹式3) {
		執行語句3
	....	
	}else{
		執行語句n
	}
	如果條件表逹式1成立則執行語句1,執行完畢後退出整個if分支語句
	如果條件表逹式1不成立時,則判斷條件表逹式2,滿足則執行語2,以此類推
	如果所有條件均不滿足都不成立時,則執行else內的語句
	<<注意>>
	1.多分支語句是多選1,最後只能有一個語句被執行
	2.else if 內的條件理論上可以任意多個的
	3.else if 中間有個空格
63三元表逹式==
	條件表逹式 ? 表逹式1 : 表逹式2
	如果條件表逹式成立時,則返回表逹式1的值,否則返回表逹式2的值,意即與二選一的if else簡寫版
	最後將返回值賦值給一個變量即可	
65 66switch語句(匹配選項)==
	針對變量設置一系列的特定值選項時使用switch語句實現多選一,switch轉換開關 case選項,主要利用表逹式的值和case後
	的值相匹配,如匹配成立,就執行case後的語句,如果未匹配上,則繼續下面的case的值匹配,如果都没有匹配上則執行default
	內的語句
	switch(表逹式){
		case 值1 :
		  執行語句1;
		  break;
		case 值2 :
		  執行語句2;
		  break;
		  ...
		default:
		最後的語句;  
	}
	1.通常表達式為一變量
	2.表逹式的值和case後面的值相匹配時,要求需全等,包含值和類型均需一致
	3.如果case後面未加break,則不會退出switch,會繼續下一個case
68if else與switch區別
	1.比較確定值時使用switch,用於判斷或範圍值較大時,使用if else語句
	2.switch語句進行條件判斷後直接執行到程序的條件語句,效率較高,if else語句則有幾個條件,就
	  得判斷多少次
	3.當分支較少時,使用if else的執行效率較switch高一些
69循環語句
  -區分為三個
	1.for 循環
	2.while循環
	3.do while循環
70-循環的目的:可以重覆執行某些語句	
71循環語句(包含循環體(重覆執行的語句)及終止條件)
	for(初始化變量;條件表逹式;操作表逹式){
		循環體
	}
	1.初始化變量就是用var聲明一個變量,通常作為計數器使用,只會執行1次
	2.條件表逹式就是用來決定每次循環是否繼續執行(終止條件)
	3.操作表逹式就是用來更新變量(遞增或遞減)(計數器更新)
	for(var i=0;i<5;i++){
		console.log('hello');
	}
73斷點調試
	F12-->source-->設置斷點-->更新-->F11下一步
75for循環重覆執行不同的代碼,因為有計數器變量i存在,每次循環值i都會變化
81雙重for循環
	for(外層初始化變量;外層條件表逹式;外層操作表逹式){
		for(內層初始化變量;內層條件表逹式;內層操作表逹式){
			執行語句;
		}
	}
	-將內層循環當作是外層循環的執行語句
	-外層循環循環一次,內層循環執行全部
86for循環小結
	1.for 循環可重復執行某些相同代碼。
	2.因為有計數器存在,for循環可重復執行些許不同的代碼。
	3.for 循環可重復執行某些操作,ex:累加操作。
	4.雙重for循環,外層for循環執行循環一次,內層for循環執行全部
87while==
	初始化變量
	while(條件表逹式){
		循環體
		操作表逹式(更新計數器,防止死循環)
	}
	當條件表逹式為true時執行循環體,否則退出循環
	如無操作表逹式時,會使整個循成為死循環
89do while==
	do while是while的變形,該循環會先執行一次循環體,然後再對條件表逹式進行判斷,如為true則
	重復執行循環體,否則退出循環
		初始化變量
		do {
		  循環體
		  操作表逹式
		} while(條件表逹式)
	do while與while 最大不同在於do while會先執行一次循環體再進行條件判斷
91循環小結==
	1.三者之間可相互替代使用
	2.用來計次數與數字相關者,使用for
	3.較複雜的條件判時使用while 或do while
92continue==
	continue關鍵字,退出本次(當前該次的循環),繼續執行剩餘次數的循環
93break==
	break關鍵字用於立即退出整個循環,剩餘的循環不再執行
97數組array==
	一組數據的集合,可存放任意類型的元素,可將一組數據存儲在一個變量下
	使用數組字面量創建數組[],元素之間以,逗號隔開,元素可以是任意數據類型
98獲取數組元素==
	透過數組元素的索引值(從0開始)
99遍歷數組==
	就是獲取數組中所有元素,方法:
		for(var i=0;i<arr.length;i++){
			console.log(arr(i));	
		}
100數組長度length==	
	數組長度是元素個數,arr.length可動態獲取元素個數
114函數概念==
	JS中的函數就是將一段可被重復調用執行的代碼塊封裝起來,日後僅需調用該函數即可,使用函數的目的就是讓大量的代碼重復使用
115函數使用
	兩大步驟:1.聲明函數	2.調用函數
	1.聲明函數方法:
		function 函數名(){
			函數體
		}
		(1)function聲明函數的關鍵字,全部小寫
		(2)函數是做某件事情,函數名一般是動詞
		(3)函數不調用自己不執行-->口訣
	2.調用函數:函數名()
	函數封裝就好像是快遞打包,將一些具有功能的代碼塊打包到函數中,方便日後執行
117函數參數==
	函數的參數可以有,也可以没有,個數不限
	1.形參:形式上的參數,接收實參傳遞的值,相當於聲明一個變量
	2.實參:實際的值,傳遞給形參
	function 函數名(形參1,形參2...){

	}
	調用函數時,函數名(實參1,實參2...)
118求任意兩個數的和
	function getSum1(num1,num2){
		console.log(num1+num2);
	}
	getSum1(3,5);//8
	求任意兩個數之間的和
119函數參數個數匹配==
	1.實參個數>形參個數-->多餘部份會被省略
	2.實參個數<形參個數-->形參未賦值時結果是undefined
	請注意形參個數=實參個數才對
120函數返回值==
	function 函數名(){
			return 需要返回的結果;
	}
	函數名()
	函數只要遇到return時就會把後面的結果返回給函數的調用者,意即函數名()=return後面的結果,我們可以將函數調用的執行結
	果賦值給一個變量保存起來,如需輸出,則僅需輸出該變量即可。
	function getSum(num1,num2){
		return num1+num2;
	}
	var result=getSum(10,20);
	console.log(result);
123使用return注意事項==
	1.return是終止函數,所以return後面的代碼不會被執行
	2.return只能返回一個值,如有逗號隔開多個值時,只會返回最後一個值
	3.如需多個值可考慮使用數組形式
	4.函數如果有return,則返回return後面的值,如return後面没有值,則會返回undefined
124break、continue、return的區別==
	break:結東當前的循環體
	continue:跳出本次循環,繼續執行下次循環
	return:不僅可以退出循環,還可返回return後面的值,並退出整個函數
126arguments的使用==
	不確定有多少個參數傳遞時,可使用arguments來獲取,arguments是當前函數的一個內置對象
	所有函數中都內建了一個arguments對象,arguments對象中存儲了傳遞所有實參。
	arguments展示形式是一個偽數組(並不是真正意義上的數組),因此可遍歷,特點:
	1.具length屬性
	2.按照索引方式儲存數據
	3.不具有數組push()、pop()等方法
	只有函數才有arguments對象,且每個函數都內建好了這個arguments對象,如此,可以不用刻
	意定義相對的形參來接收實參所傳遞過來的值
133函數兩種聲明方式==
	1.函數聲明:function 函數名(){}
	2.函數表逹式:var 變量名=function(){}
		a.使用匿名函數,並將其賦值給一個變量,裏面存的是值,而函數表逹式裏面存的昰函數
		b.也可以傳遞參數。
135作用域==
	就是代碼名字(變量)在某個範圍內起作用和效果,目的是為了提高程序的可靠性,更重要的是減少命名衝突
	JS的作用域(ES6)之前:區分為兩種:全局作用域、局部作用域
	全局作用域:指整個script標籤內或單獨的JS文件中(外部引用時)
	局部作用域:指在函數內部使用,變量作用範圍只在函數內部起作用和有效果。
136變量作用域==
	變量作用域:根據作域的不同,區分為全局變量和局部變量
	1.全局變量:在全局作用域下的變量,在全局中均可使用,但如果在函數內部,只有賦值,但未聲明的變量也會轉為全局變量
	2.局部變量:在局部作用域下的變量,只能在函數內部使用,函數形參也可以視為局部變量
	從執行效率來看全局變量和局部變量:
	(1)全局變量只有在瀏覽器關閉時才會銷毀,比較佔記憶體資源
	(2)局部變量則是當函數執行完畢就會銷毀,比較節省記憶體資源
137JS塊級作用域==
	ES6才有塊級作用域,使用{}括起來的範圍,ES6以前没有
138作用域鏈==
	函數內部可以使用外部函數的變量或全局變量,由內可以往外找(就近原則),但由函數外部無法使用函數內部變量
141預解析(變量提前聲明)==
	- Js解析器在解析JS代碼時分成兩步:預解析和依序執行代碼
	- 預解析:JS引擎會把JS中所有的var 和function提升到當前作用域的最前面
	- 預解析分為變量預解析(變量提升)和函數預解析(函數提升)
		(1)變量提升就是把所有的變量聲明提升到當前作用域最前面,但不賦值
		(2)函數提升就是把所有的函數聲明提升到當前作用域最前面,但不調用函數
			 以函數表逹式創建的函數無函數聲明提前功能,所以調用函數仍需寫在函數表逹式後面否則會報錯
	var a = b = c = 9;相當於var a = 9; b = 9 ;c = 9;-->b和c是未聲明變量,直接賦值,視為全局變量
	與聲明同時賦值不同:var a = 9,b = 9,c=9;以逗號隔開,var a=9; var b=9; var c=9;
144JS對象==
	對象是一個具體的事物,在JS中對象是一組無序的相關屬性和方法的集合,由屬性和方法組成。
	屬性:事件的特徵,在對象中用屬性來表示(常用名詞)--外表
	方法:事件的行為,在對象中用方法來表示(常用動詞)--功能
	保存一個值時,可使用變量,保存多個值時,可使用數組,但要保存一個人的完整信息?使用對象來保存表逹結構更清晰更強大。
145創建對象(object)的三種方式==
	1.對象字面量:使用{} var obj={}; 
		var obj={
			name:'王大',
			age:18,
			sex:'男',
			sayhello:function(){
				console.log()
		  }
		}
		(1)屬性或方法採用 屬性名:屬性值 方式表示
		(2)多個屬性或方法間使用逗號隔開
		(3)方法時冒號後面跟著一個匿名函數
	2.使用對象
		(1)調用對象的屬性: 對象名.屬性名 .理解為"的"
		(2)另一種調用對象屬性: 對象名['屬性名']
		(3)調用對象的方法: 對象名.方法名()-->注意要加上()
146變量、屬性、函數、方法總結==
	1.變量和屬性的相同點:均是用來存儲數據的,不同點:
		變量:單獨聲明並賦值,使用時直接寫變量名,單獨存在
		屬性:在對象中不需聲明,使用時需使用 對象名.屬性
	2.函數和方法相同點:均是用來實現某種功能,做某件事
		函數是單獨聲明單獨存在的,且調用時使用 函數名()
		方法(對象中的函數稱為方法,用來描述對象的行為和功能)則是在對象中,不需要聲明,調用時使用 對象名.方法()
147使用new創建對象==
	var obj= new Object();創建一個空的對象
	新增屬性和方法:
	obj.name='王八';
	obj.age=18;
	obj.sayHi=function(){
		函數體
	};
	(1)利用等號=賦值方式添加對象的屬性和方法
	(2)每個屬性和方法以分號結束
148使用構造函數創建對象==
	為什麼需要使用構造函數創建對象,因為前面兩種方式一次只能創建一個對象,其中如果有很多屬性和方法相同時
	,只能使用複製,因此可使用函數的方法,將這些重複相同的代碼,封裝成構造函數,構造函數中封裝的是對象,就是
	將對象中一些公共的屬性和方法抽取出來封裝到函數裏面
149構造函數()
	function 構造函數名(){  //首字母大寫
		this.屬性 = 值;
		this.方法 = function(){}
	}
	調用時:
	 new 構造函數名();
	規範:
	  (1)構造函數名首字母大寫
		(2)構造函數不需要return就可以返回結果
		(3)調用構造函數時需使用new關鍵字
		(4)調用構造函數時同時創建一個新對象
		(5)屬性和方法前面必須添加this
152new關鍵字==
	new關鍵字執行過程四步曲:
	1.new構造函數可在記憶體中創建一個空的對象
	2.this就會指向剛創建的空對象
	3.執行構造函數裏面的代碼,給這個空對象添加屬性和方法
	4.返回這個新對象(所以構造函數裏面不需要return)
153遍歷對象屬性==
 for..in語句:用於遍歷對象
   for ( var 變量 in 對象){  
		console.log(變量)	 -->可遍歷屬性名
		console.log(obj[變量])-->可遍歷屬性值,不用加引號
   }
	使用for in中的變量,通常使用k或key

內建對象============================================================
	對象區分三種:自定義對象、內建對象(DOM)、瀏覽器對象(BOM)
	- 內建對象乃是JS語言自帶的一些對象,提供開發者直接使用,內含一些基本或常用的屬性和方法,執行某些功能和效果
	- MDN-查說明看功能,如何使用語法,是否需參數,返回值意義和類型
  - Javascript參考手冊
Math對象==
	1.不是構造函數,直接使用屬性和方法
		(1)PI屬性:	console.log(Math.PI);
		(2)Math.max()方法:  console.log(Math.max(1,3,9))
		(3)Math.round()方法:四捨五入,.5較特殊,它往大值取
		(4)Math.floor():向下取整
		(5)Math.ceil():向上取整
	07random()隨機數方法
		1.返回一個隨機0~1的小數(0<=x<1),不用加參數
		2.可以得到一個兩數之間的隨機整數,包括前後兩個數在內(公式參考MDN)
			Math.floor(Math.random() * (max - min + 1)) + min;
  	3.猜數字遊戲
日期對象(Date)==			
	09日期對象
		1.是一個構造函數,需使用new來調用並創建日期對象,未加參數時代表系統當前日期時間
			var date=new Date();
			console.log(date);
		2.參數常用寫法:數字型2019,8,8 或字符串型'2019-08-08 08:08:08'	
		3.getMonth()月份部份必須加1,getDay()星期則返回的是0~6,0表星期日,1表星期一...
	12獲取時間戳(總毫秒數)
		1.總毫秒數是當前系統時間距離1970年1月1日所經歷的總毫秒數,數字不會重複
		2.四種獲取方法:
			(1)valueOf()
			(2)getTime()
			(3)var date=+new Date()-->使用+new 常用
			(4)Date.now():H5新增,獲取總毫秒數
	14倒數計時:輸入的時間減去現在的時間就是剩餘時間,利用時間戳來完成,再轉換為天.時.分.秒
數組對象==
	16檢測是否為數組
		1.instanceof 運算符,用來檢測對象的形態  
		2.Array.isArray(檢測值) H5新增的方法,IE9以上版本支持
	17添加數組元素==
		1.push(參數1,參數2...)在數組的末尾添加一個或多個數組新元素,並返回新數組長度
		2.unshift(參數1,參數2...)在數組的開頭添加一個或多個數組新元素,並返回新數組長度
	18刪除數組元素==
		1.pop()用於刪除數組最後一個元素,返回值為刪除那個元素,不用參數
		2.shift()用於刪除數組開頭一個元素,返回值為刪除那個元素,不用參數
	20數組排序==
		1.reverse()順序翻轉
		2.sort()數組排序(冒泡排序)-->
			sort(function(a,b){
				return a-b;  //升序排列
				return b-a;  //降序排列
			})
	21獲取數組元素索引==
		-indexOf(數組元素),從前面開查找指定的元素並返回數組元素的索引號,元素如有重覆時只返回第一個滿足	條件的
		  索引號,如找到該元素時返回-1
		-lastIndexOf(數組元素),從後面往前查找元素並返回元素的索引號,如找不到時返回-1
	22數組去重==
		重要案例,加強練習
	23數組轉換為字符串==
		1.toString():轉換後以逗號隔開
		2.join('分隔符'):可以使用其他符號隔開ex:arr.join('-')或arr.join('&')
字符串對象==
	對象才有屬性和方法,引用數據類型才有屬性和方法,基本數據類型為何有length屬性?
	-基本包裝類型:就是將基本數據類型包裝成為引用數據類型
	var str='coca';
	console.log(str.length);//4-->基本數據類型為何有length屬性?因為它們執行了下列程序
	(1)把基本數據類型包裝為引用數據類型
		var temp=new String('coca');
	(2)把臨時變量的值賦值給str
	  str=temp;
	(3)銷毀這個臨時變量
		temp=null;
	JS提供三個特殊的引用類型:String,Number,Boolean
  25字符串的不可變性==
  	因為字符串的不可變性,指的是裏面的值不可變,雖然看上去改變內容了,但其實是地址變了,內存中又新開闢了
		一個內存空間,然後將新值放入,原來的字符串仍存在未消失,所以不要大量的拼接字符串
  26根據字符返回位置==
  	字符串所有的方法,都不會修改字符串本身(字符串是不可變的),操作完成會返回一個新的字符串
  	indexOf('要查找的字符',[起始位置])  起始位置是索引值,從起始位置往後查找
		lastIndexOf()從後面往前找 	
	28根據位置返回字符==
		1.charAt(index):根據位置返回字符,可用來遍歷字符串
		2.charCodeAt():會返回相應索引的字符ASCII值,目的:判斷用戶按下了那一個鍵
		3.str[index]:H5新增的
	31字符串方法==
		1.concat('字符串1','字符串2'...):用於連接兩個或多個字符串,作字符串拼接,實務上大多使用+
		2.substr(截取的起始位置start,截取長度length):截取字符串
	32替換字符、轉換為數組==
		1.replace('被替換的字符','替換為的字符'):它只會替換第一個字符
		2.split('分隔符'):取決於字符串中以何種分隔符隔開,將字符串轉換為數組==>join()把數組轉換為字符串,
數據類型總結==	
	34基本數據類型
		null-->返回的是一個空對象object
		如變量打算存儲為對象,但暫時還没想好放啥,此時可先賦值為null
		基本數據類型存於棧內存,存放的是值,
		引用數據類型存於堆內存,首先在棧內存放地址(16進制),然後這個地址指向堆內的值
	35基本數據類型傳參==
		函數的形參可視為一個變量,當把一個值類型變量作為參數傳給函數的形參時,其實是把變量在棧內存中的值複
		製一份給形參,因此在方法內部對形參做任何修改,均不影響外部變量
		function fn(a){
			a++;
			console.log(a);  //11
		}
		var x =10;
		fn(x);
		console.log(x);    //10
	36引用數據類型傳參==
		函數的形參可視為一個變量,當我們把引用類型變量傳給形參時,其實是把變量在拡空間中保存的堆地址複製
		一份傳給了形參,形參和實參保存的是同一個堆地址,所以操作的同一個對象
		function Person(name){
			this.name=name;
		}
		function f1(x){
			console.log(x.name);       //劉德華
			x.name='張學友';
			console.log(x.name);			//張學友
		}
		var p=new Person('劉德華');
		console.log(p.name);        //劉德華      
		f1(p);
		console.log(p.name);				//張學友