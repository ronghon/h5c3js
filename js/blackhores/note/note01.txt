05javascript簡介--編程語言,控制人與計算機之間交互的行為
	javascript是一種運行在客戶端的腳本語言,不需要編譯,而是由js解釋器(js引擎)逐行進行解釋並執行
	作用:
		1.表單驗證
		2.網頁特效
		3.服務端開發(node.js)
		4.桌面程序
		5.App
		6.控制硬體-物聯網(Ruff)
		7.游戲開發...
06瀏覽器分成兩部份--渲染引擎和JS引擎
  渲染引擎:用來解析HTML與CSS,俗稱內核,chrome的blink
	JS引擎:用來讀取網頁中的Javascript代碼,chrome瀏覽器的V8,JS引擎執行代碼時係逐行解釋每一句源碼,然後由計算機去執行
	所以Javascript語言歸類為腳本語言,會逐行解釋執行。
07JS組成==
	ECMAScript(JS基礎語法)、BOM、DOM(Web API)
08編寫位置==
	1.行內JS--直接寫到元素的內部
	2.內嵌式JS--在head中使用<script></script>中間有個空格
	3.外部JS--在head中使用<script src="demo.js"></script>引入js文件,在<script>之間不可再寫代碼
09注釋==
	//單行注釋  ctrl+/
	/* 多行注釋 */   ctrl+shift+/
10輸入框prompt('請輸入1-10數字');
  console.log()輸出到控制台
	alert()彈出框
12變量==
	變量是程序在內存中開闢一塊用來存放數據的空間
	使用步驟:1.使用var聲明變量 var 變量名
				 	2.賦值  name=10;
	變量初始化:聲明變量同時賦值  var myName=10;
16變量語法擴展==
	1.更新變量:以最後一個賦值為準
	2.同時聲明多個變量:每個變量之間以逗號隔開
	3.只聲明不賦值:結果為undefined(未定義)
	4.未聲明且不賦值:結果是報錯
	5.不聲明直接賦值:成為全局變量
17變量命名規範==
	1.區分大小寫,不可以數字開頭,不可使用關鍵字或保留字
	2.變量名可見名思義,以駝峰命名法開頭小寫後面單詞的首字母大寫
	3.可使用英文字母,數字、下劃線、美元符$
18交換變量值==
	利用空的臨時變量(temp)
21數據類型簡介==
	-javascript是一種弱類型語言,意味著不用提前聲明變量的類型,在程序運行過程中,根據等號右邊的值的類型來確認。
	-js屬於動態語言,變量的數據類型是可以變化的,相同的變量可作不同類型的轉換,以最後一個賦值為主。
22數據類型分類==
	基本數據類型:Number、Boolean、String、Null、Underfined
	複合數據類型:Object
	八進制  --> 0~7
	十六進制 -->0~9 a~f 0x
	數字型的最大值Number.MAX_VALUE
	數字型的最小值Number.MIN_VALUE
	無窮大 -->Infinity
	無窮小 -->-Infinity
	NAN   -->非數字
23 isNaN==通常用來驗證用戶輸入值是否為數字型
	isNaN()-->用來判斷值是否為非數字
						true:是非數字
						false:是數字
24字符串String==
	-加單引號或雙引號者,嵌套時外雙內單
	-轉義字符 用\開頭ex-->\n:換行  \\:斜摃\  \b:空格  \t:tab縮進
26字符串長度與拼接==
	-檢查並獲取字符串長度時,使用length屬性
	ex: var str='my name is andy';
	    console.log(str.length);  //15
	-字符串拼接:使用+進行拼接,字符串+任何類型=拼接之後的新字符串,任何數據類型與字符串相加時為字符串拼接
	變量和字符串相連的口訣-->引引加加
30獲取數據類型==
	-使用typeof檢查數據類型  console.log(typeof null)  //object
	-使用prompt()取出來的值是字符串類型,如要數值運算時需執行數據類型轉換
31字面量==
	字面量:固定值的表示法
32數據類型轉換1==
  -轉成字符串類型
		1.toString()-->變量.toString()
		2.String()-->函數  String(變量)
		3.加號拼接字符串-->變量+''(空字符串)-->隱式轉換
33 34數據類型轉換2==  
  -轉成數值類型	
		1.parseInt(變量)函數-->將string類型轉成整數數值類型(取整,不會四捨五入進位,由左往右取,遇非數值時就停止)
		2.parseFloat(string)函數-->將string類型轉成整數或浮點數數值類型(取整或取小數點)
		3.Number(變量)強制轉換函數-->將string類型轉成數值類型
		4.js隠式轉換(- * /)-->利用運算式進行隠式轉換為數值 (-0 *1 /1)
37轉成Boolean==
	使用Boolean()函數
	'' 0 NaN null undefind -->均轉成false	其餘值均轉成true
38解釋型語言與編譯型語言==
	Java為編譯型語言,會整個編譯後產生新的文件;Javascript為解釋型語言,逐行解釋並立即執行
42運算符(操作符)==
	-包括算術  比較  邏輯  賦值  遞增(減)
	-不要直接使用浮點數作為比較判斷是否相等-->浮點數會有精確度問題
	-整除-->使用%取餘
43 44 45 46 47表逹式與返回值==
	-表逹式:由數字,運算符,變量等組成的式子
	-將右邉表逹式運算結果返回給左邉的變量,所有表逹式均會有一個結果返回給我們,稱之為返回值
	++變量-->前置自增(先自增,後返回值)
	變量++-->後置自增(先返回原值,後自增)
	(前置自增和後置自增如果單獨使用時,效果相同)
48比較(關係)運算符==
	-會返回布林值(true false)
	 '='賦值,將右邊給左邊	
	 '=='判斷是否相等-->會轉換類型,只要求值是否相等
	 '==='全等-->不會轉換類型,包含值和類型是否全都相同
49邏輯運算符==
	-也是會返回布林值(true false)
	&&'與'-->and-->找false(只要為第一個表逹式返回值為false時即返回false,如為true再進行第二個表逹式判斷) 
	||'或'-->or -->找true	(只要為第一個表逹式返回值為true時即返回true,如為false再進行第二個表逹式判斷)
	! '非'-->not-->取反
51 52短路運算(邏輯中斷)==
	從左到右判斷,邏輯中斷會影響程序運行結果
	1.&&(找false):
	  表逹式1 && 表逹式2
	  如果表逹式1為true,則返回表逹式2
	  如果表逹式1為false,則返回表逹式1(表逹式2不會再進行判斷)
	2.||(找true):
	  表逹式1 || 表逹式2
	  如果表逹式1為true,則返回表逹式1(表逹式2不會再進行判斷)
	  如果表逹式1為false,則返回表逹式2
53賦值運算符==
	num++ -->num = num + 1 後自增1
	num += 2 -->num = num + 2  每次自増2
	num += 5 -->num = num + 5  每次自増5
	num *= 3 -->num = num * 3 
54運算符優先級==
	() ->  一元運算符 -> 算術  -> 關係 -> 相等 -> 邏輯 -> 賦值 -> 逗號
55流程控制==
	-三種-順序結構、分支結構、循循結構
	1.分支結構-if語句,switch語句
	  if (條件表逹式){
	  	執行語句
	  }    
  	條件為true-->執行語句
	  條件為false-->不執行語句,並跳出if執行後面的代碼
59if else語句雙分支(二選一)==
	if (條件表逹式){
		執行語句1
	} else{
		執行語句2	
	}
	如果條件表逹式為true,則執行語句1,如為false則執行語句2,在這個雙分支語句最終只能有一個語句被執行
60潤年與平年判斷==
	能被4整除且不能整除100者為潤年,或能被400整除的就是潤年
	var year =prompt('請輸入判斷年份');
	if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0){
		alert('你輸入的年份是潤年');		
	} else{
		alert('你輸入的年份是平年');
	}
61if else if(多分支語句)(多選1)==
	多分支語句,就是利用多個條件來選擇不同的語句執行,為多選1的過程
	if (條件表逹式1){
		執行語句1
	}else if(條件表逹式2) {
		執行語句2
	}else if(條件表逹式3) {
		執行語句3
	....	
	}else{
		執行語句n
	}
	如果條件表逹式1成立則執行語句1,執行完畢後退出整個if分支語句
	如果條件表逹式1不成立時,則判斷條件表逹式2,滿足則執行語2,以此類推
	如果所有條件均不滿足都不成立時,則執行else內的語句
	<<注意>>
	1.多分支語句是多選1,最後只能有一個語句被執行
	2.else if 內的條件理論上可以任意多個的
	3.else if 中間有個空格
63三元表逹式==(二選一)
	條件表逹式 ? 表逹式1 : 表逹式2
	如果條件表逹式成立時,則返回表逹式1的值,否則返回表逹式2的值,意即與二選一的if else簡寫版
	最後將返回值賦值給一個變量即可	
65 66switch語句(匹配選項)==
	針對變量設置一系列的特定值選項時使用switch語句實現多選一,switch轉換開關 case選項,主要利用表逹式的值和case後
	的值相匹配,如匹配成立,就執行case後的語句,如果未匹配上,則繼續下面的case的值匹配,如果都没有匹配上則執行default
	內的語句
	switch(表逹式){
		case 值1 :
		  執行語句1;
		  break;
		case 值2 :
		  執行語句2;
		  break;
		  ...
		default:
		最後的語句;  
	}
	1.通常表達式為一變量
	2.表逹式的值和case後面的值相匹配時,要求需全等(===),包含值和類型均需一致
	3.如果case後面未加break,則不會退出switch,會繼續下一個case
68if else if與switch區別(多選一)
	1.比較確定值(固定值)時使用switch,用於判斷或範圍值較大時,使用if else if語句
	2.switch語句進行條件判斷後直接執行到程序的條件語句,效率較高,if elseif 語句則有幾個條件,就
	  得判斷多少次
	3.當分支較少時,使用if else的執行效率較switch高一些
	4.分支較多時,switch語句的執行效率比較高,且結構更清晰。
69循環語句
  -區分為三個
	1.for 循環
	2.while循環
	3.do while循環
70-循環的目的:可以重覆執行某些語句	
71循環語句(包含循環體(重覆執行的語句)及終止條件)
	for(初始化變量;條件表逹式;操作表逹式){
		循環體
	}
	1.初始化變量就是用var聲明一個變量,通常作為計數器使用,只會執行1次
	2.條件表逹式就是用來決定每次循環是否繼續執行(終止條件)
	3.操作表逹式就是用來更新計數器變量(遞增或遞減)(計數器更新)
	for(var i = 0 ; i < 5 ; i++){
		console.log('hello');
	}
73斷點調試
	F12-->source-->設置斷點-->更新-->F11下一步
75for循環重覆執行不同的代碼,因為有計數器變量i存在,每次循環值i都會變化
81雙重for循環
	for(外層初始化變量;外層條件表逹式;外層操作表逹式){
		for(內層初始化變量;內層條件表逹式;內層操作表逹式){
			執行語句;
		}
	}
	-將內層循環當作是外層循環的執行語句
	-外層循環循環一次,內層循環執行全部
86for循環小結
	1.for 循環可重復執行某些相同代碼。
	2.因為有計數器存在,for循環可重復執行些許不同的代碼。
	3.for 循環可重復執行某些操作,ex:累加操作。
	4.雙重for循環,外層for循環執行循環一次,內層for循環執行全部
87while==
	初始化變量
	while(條件表逹式){
		循環體
		操作表逹式(更新計數器,防止死循環)
	}
	當條件表逹式為true時執行循環體,否則退出循環
	如無操作表逹式時,會使整個循環成為死循環
89do while==
	do while是while的變形,該循環會先執行一次循環體,然後再對條件表逹式進行判斷,如為true則
	重復執行循環體,否則退出循環
		初始化變量
		do {
		  循環體
		  操作表逹式
		} while(條件表逹式)
	do while與while 最大不同在於do while會先執行一次循環體再進行條件判斷
91循環小結==
	1.三者之間可相互替代使用
	2.用來計次數與數字相關者,使用for
	3.較複雜的條件判時使用while 或do while
92continue==
	continue關鍵字,退出本次(當前該次的循環),繼續執行剩餘次數的循環
93break==
	break關鍵字用於立即退出整個循環,剩餘的循環不再執行
94標識符命名規範==
	變量的名稱一般使用名詞,函數的名稱使用動詞
97數組array==
	1.定義:一組數據的集合,每個數據稱為元素,可存放任意類型的元素,將一組數據存儲在一個變量下的
	      一種模式,<-->相較以往一個變量只存一個值的情況,更廣泛應用。
	2.創建數組:
	  (1)使用new關鍵字創建數組:
			 var 數組名 = new Array();-->創建一個空的數組
			 var arr = new Array(2);-->表示創建一個長度為2的新數組,內含2個空的數組元素
			 var arr = new Array(2,3);-->表示創建一個新數組,數組元素為2,3
		(2)使用數組字面量創建數組:
		   var 數組名 = []  元素之間以,逗號隔開,元素可以是任意數據類型
			 var arr=[1,2,3,4] 創建數組並賦值稱為數組的初始化
98獲取數組元素==
	透過數組元素的索引值(從0開始) ex:cosole.log(arr[0])獲取arr數組索引值為0的值,如無該索引值,則會返回undefined。
99遍歷數組==所謂遍歷就是把數組中的每個元素從頭到尾都訪問一遍
	就是獲取數組中所有元素,方法--利用for循環:
		for(var i=0;i<arr.length;i++){
			console.log(arr[i]);	
		}
		i為計數器,當索引值使用,索引值從0開始,所以i=0, 數組長度length=最大索引值+1 ,所以i< arr.length
		arr[i]表示數組元素中第i個元素
100數組長度length==	
	數組長度是數組中的元素個數,可利用arr.length動態監測元素個數,
104新增數組元素==
  1.透過修改length長度來實現數組擴展,如未賦值則為undefined
	2.透過修改數組索引值方式,如要向數組最後一個位置添加一個元素時,可使用--> 數組名[數組名.length]=值
		特別注意:不可以直接給數組名賦值,否則會覆蓋掉原數組元素。
114函數概念==
	JS中的函數就是將一段可被重復調用執行的代碼塊封裝起來,日後僅需調用該函數即可,使用函數的目的就是讓大量的代碼重復使用
115函數使用==
	兩大步驟:1.聲明函數	2.調用函數
	1.聲明函數方法:
		function 函數名(){
			函數體
		}
		(1)使用function關鍵字聲明函數,全部小寫
		(2)函數是為了做某件事情,函數名一般是動詞
		(3)函數不調用自己不執行-->口訣
	2.調用函數:函數名()
	函數封裝就好像是快遞打包,將一些具有功能的代碼塊打包到函數中,方便日後執行
117函數參數==
	函數的參數可以有,也可以没有,個數不限
	1.形參:形式上的參數,接收實參傳遞的值,相當於聲明一個變量並給予賦值
	2.實參:實際的值,傳遞給形參
	function 函數名(形參1,形參2...){

	}
	調用函數時,函數名(實參1,實參2...)
	參數的作用:在函數內部某些值不固定時,可通過參數在調用函數時傳遞不同的值進去
118求任意兩個數的和
	function getSum1(num1,num2){
		console.log(num1+num2);
	}
	getSum1(3,5);//8
	求任意兩個數之間的和
119函數參數個數匹配==
	1.實參個數>形參個數-->多餘部份會被省略
	2.實參個數<形參個數-->形參未賦值時結果是undefined
	請注意形參個數=實參個數才對
120函數返回值==
	function 函數名(){
			return 需要返回的結果;
	}
	函數名()
	函數只要遇到return時就會把後面的結果返回給函數的調用者,意即函數名()=return後面的結果,我們可以將函數調用的執行結
	果賦值給一個變量保存起來,如需輸出,則僅需輸出該變量即可。
	function getSum(num1,num2){
		return num1+num2;
	}
	var result=getSum(10,20);
	console.log(result);
123使用return注意事項==
	1.return是終止函數,所以return後面的代碼不會被執行
	2.return只能返回一個值,如有逗號隔開多個值時,只會返回最後一個值
	3.如需多個值可考慮使用數組形式
	4.函數如果有return,則返回return後面的值,如return後面没有值,則會返回undefined
124break、continue、return的區別==
	break:結東當前的循環體
	continue:跳出本次循環,繼續執行下次循環
	return:不僅可以退出循環,還可返回return後面的值,並退出整個函數
126arguments的使用==
	不確定有多少個參數傳遞時,可使用arguments來獲取,arguments是當前函數的一個內置對象
	所有函數中都內建了一個arguments對象,arguments對象中存儲了傳遞所有實參。
	arguments展示形式是一個偽數組(並不是真正意義上的數組),因此可遍歷,特點:
	1.具length屬性
	2.按照索引方式儲存數據
	3.不具有數組push()、pop()等方法
	只有函數才有arguments對象,且每個函數都內建好了這個arguments對象,如此,可以不用刻
	意定義相對的形參來接收實參所傳遞過來的值
133函數兩種聲明方式==
	1.函數聲明:function 函數名(){}
	2.函數表逹式:var 變量名=function(){}
		a.使用匿名函數,並將其賦值給一個變量,裏面存的是值,而函數表逹式裏面存的昰函數
		b.也可以傳遞參數。
135作用域==
	就是代碼名字(變量)在某個範圍內起作用和效果,目的是為了提高程序的可靠性,更重要的是減少命名衝突
	JS的作用域(ES6)之前:區分為兩種:全局作用域、局部作用域
	全局作用域:指整個script標籤內或單獨的JS文件中(外部引用時)
	局部作用域:指在函數內部使用,變量作用範圍只在函數內部起作用和有效果。
136變量作用域==
	變量作用域:根據作域的不同,區分為全局變量和局部變量
	1.全局變量:在全局作用域下的變量,在全局中均可使用,但如果在函數內部,只有賦值,但未聲明的變量也會轉為全局變量
	2.局部變量:在局部作用域下的變量,只能在函數內部使用,函數形參也可以視為局部變量
	從執行效率來看全局變量和局部變量:
	(1)全局變量只有在瀏覽器關閉時才會銷毀,比較佔記憶體資源
	(2)局部變量則是當函數執行完畢就會銷毀,比較節省記憶體資源
137JS塊級作用域==
	ES6才有塊級作用域,使用{}括起來的範圍,ES6以前没有
138作用域鏈==
	函數內部可以使用外部函數的變量或全局變量,由內可以往外找(就近原則),但由函數外部無法使用函數內部變量
141預解析(變量提前聲明)==
	- Js解析器在解析JS代碼時分成兩步:預解析和依序執行代碼
	- 預解析:JS引擎會把JS中所有的var 和function提升到當前作用域的最前面
	- 預解析分為變量預解析(變量提升)和函數預解析(函數提升)
		(1)變量提升就是把所有的變量聲明提升到當前作用域最前面,但不賦值
		(2)函數提升就是把所有的函數聲明提升到當前作用域最前面,但不調用函數
			 以函數表逹式創建的函數無函數聲明提前功能,所以調用函數仍需寫在函數表逹式後面否則會報錯
	var a = b = c = 9;相當於var a = 9; b = 9 ;c = 9;-->b和c是未聲明變量,直接賦值,視為全局變量
	與聲明同時賦值不同:var a = 9,b = 9,c=9;以逗號隔開,var a=9; var b=9; var c=9;
144JS對象(object)==
	對象是一個具體的事物,在JS中對象是一組無序的相關屬性和方法的集合,由屬性和方法組成。
	屬性:事件的特徵,在對象中用屬性來表示(常用名詞)--外表
	方法:事件的行為,在對象中用方法來表示(常用動詞)--功能
	保存一個值時,可使用變量,保存多個值時,可使用數組,但要保存一個人的完整信息?使用對象來保存表逹結構更清晰更強大。
145創建對象(object)的三種方式==
	-利用字面量創建對象
	-利用new Object創建對象
	-利用構造函數創建對象	
	1.對象字面量:使用{} var obj={}創建一個空對象; {}內包含表逹這個對象的屬性和方法
		var obj={
			name:'王大',  //屬性
			age:18,
			sex:'男',    
			sayhello:function(){  //匿名函數-->方法
				console.log()
		  }
		}
		(1)屬性或方法採用 屬性名:屬性值 方式表示
		(2)多個屬性或方法間使用逗號隔開
		(3)方法時冒號後面跟著一個匿名函數
	2.使用對象
		(1)調用對象的屬性: 對象名.屬性名 .理解為"的"
		(2)另一種調用對象屬性: 對象名['屬性名']
		(3)調用對象的方法: 對象名.方法名()-->注意要加上()
146變量、屬性、函數、方法總結==
	1.變量和屬性的相同點:均是用來存儲數據的,不同點:
		變量:單獨聲明並賦值,使用時直接寫變量名,單獨存在
		屬性:在對象中不需聲明,使用時需使用 對象名.屬性
	2.函數和方法相同點:均是用來實現某種功能,做某件事
		函數是單獨聲明單獨存在的,且調用時使用 函數名()
		方法(對象中的函數稱為方法,用來描述對象的行為和功能)則是在對象中,不需要聲明,調用時使用 對象名.方法()
147使用new創建對象==
	var obj= new Object();創建一個空的對象 <--"O"要大寫
	新增屬性和方法:
	obj.name='王八';
	obj.age=18;
	obj.sayHi=function(){
		函數體
	};
	(1)利用 等號= 賦值方式添加對象的屬性和方法
	(2)每個屬性和方法以分號結束
	(3)調用時使用對象名.屬性名或對象名['屬性名']或對象.方法名()
148使用構造函數創建對象==
	為什麼需要使用構造函數創建對象,因為前面兩種方式一次只能創建一個對象,其中如果有很多屬性和方法相同時
	,只能使用複製,因此可使用函數的方法,將這些重複相同的代碼,封裝成構造函數,構造函數中封裝的是對象,就是
	將對象中一些公共的屬性和方法抽取出來封裝到函數裏面
149構造函數():是一種特殊的函數,主要用來初始化對象,也就是為對象成員變量賦予初始值,它總是與new運算符一起使用
	1.聲明構造函數語法:
		function 構造函數名(){  //首字母大寫
			this.屬性 = 值;
			this.方法 = function(){}
		}
	2.調用時:
	   new 構造函數名();
	3.規範:
	  (1)構造函數名首字母大寫
		(2)構造函數不需要return就可以返回結果
		(3)調用構造函數時需使用new關鍵字
		(4)調用構造函數時同時創建一個新對象
		(5)屬性和方法前面必須添加this
151構造函數和對象==
	1.對象 ex:劉德華,"特指"其中的某一個具體的事物,..調用函數時返回時同時創建一個新對象
	2.構造函數 ex:明星,是抽象了對象的公共部份,封裝到函數內,它"泛指"的是某一大類
	3.利用new關鍵字創建對象的過程也稱為對象的實例化		
152new關鍵字==
	new關鍵字執行過程四步曲:
	1.new構造函數可在記憶體中創建一個空的對象        -->生了一個寶寶
	2.this就會指向剛創建的空對象                   -->這個寶寶需是親生的this指向
	3.執行構造函數裏面的代碼,給這個空對象添加屬性和方法-->教孩子讀書寫字(加屬性和方法)
	4.返回這個新對象(所以構造函數裏面不需要return)   -->回報父母(返回新對象)
153遍歷對象屬性==
  for..in語句:用於遍歷對象
   for ( var 變量 in 對象){  
		console.log(變量)	 -->可遍歷屬性名
		console.log(obj[變量])-->可遍歷屬性值,不用加引號
   }
	使用for in中的變量,通常使用k或key
154對象小結==
	1.對象可以讓代碼結構更清晰
	2.對象屬於複雜的數據類型object
	3.對象的本質就是一組無序的相關屬性和方法的集合
	4.構造函數泛指某一大類
	5.對象實例特指某一個具體的事物,可利用構造函數創建新的對象稱之為對象的實例化
	6.使用for...in語句來遍歷對象的屬性進行循環操作

02內建對象============================================================
	JS對象區分三種:自定義對象、內建對象(DOM)(前面兩種屬於ECMAScript)、瀏覽器對象(BOM)-->JS獨有
	- 內建對象乃是JS語言自帶的一些對象,提供開發者直接使用,內含一些基本或常用的屬性和方法,可用來執行某些功能和效果
	- MDN-查說明看功能,如何使用語法,是否需參數,返回值意義和類型,再透過demo進行測試一下
  - Javascript參考手冊
Math對象==
04.不是構造函數,直接使用屬性和方法
		(1)PI屬性:	console.log(Math.PI);
		(2)Math.max()方法:  console.log(Math.max(1,3,9))
		(3)Math.round()方法:四捨五入,.5較特殊,它往大值取,-1.5-->-1
		(4)Math.floor():向下取整,無條件捨去
		(5)Math.ceil():向上取整,無條件進位
07.random()隨機數方法,不用加參數,隨機抽奬、隨機點名
		1.返回一個隨機0~1的小數(0<=x<1),不用加參數
		2.可以得到一個兩數之間的隨機整數,包括前後兩個數在內(公式參考MDN)
			Math.floor(Math.random() * (max - min + 1)) + min;
08.猜數字遊戲
日期對象(Date)==			
09.日期對象
		1.是一個構造函數,需使用new來調用並創建日期對象,未加參數時代表系統當前日期時間
			var date=new Date();
			console.log(date);
		2.參數常用寫法:數字型2019,8,8 或字符串型'2019-08-08 08:08:08'	
		3.getMonth()月份部份必須加1,getDay()星期則返回的是0~6,0表星期日,1表星期一...
		4.如要在時間前面補0的話可利用下列程序:
		  h = h < 10 ? '0' + h : h;
12.獲取時間戳(總毫秒數)
		1.總毫秒數是當前系統時間距離1970年1月1日所經歷的總毫秒數,數字不會重複
		2.四種獲取方法:
			(1)valueOf()
			(2)getTime()
			(3)var date=+new Date()-->使用+new 常用
			(4)Date.now():H5新增,獲取總毫秒數
14.倒數計時:輸入的時間減去現在的時間就是剩餘時間,利用時間戳來完成,再轉換為天.時.分.秒
數組對象==
16.檢測是否為數組
		1.instanceof 運算符,用來檢測對象的形態  ex:  arr instanceof Array;  obj instanceof Object;
		2.Array.isArray(檢測值) H5新增的方法,IE9以上版本支持
17.添加數組元素==
		1.push(參數1,參數2...)在數組的末尾添加一個或多個數組新元素,並返回新數組長度
		2.unshift(參數1,參數2...)在數組的開頭添加一個或多個數組新元素,並返回新數組長度
18.刪除數組元素==
		1.pop()用於刪除數組最後一個元素,返回值為刪除那個元素,不用參數
		2.shift()用於刪除數組開頭一個元素,返回值為刪除那個元素,不用參數
20.數組排序==
		1.reverse()翻轉數組排序
		2.sort()數組排序(冒泡排序)-->1,10,11,12,2,20,21會先依個位數,十位數先排序,解決方法如下:
			sort(function(a,b){
				return a-b;  //升序排列
				return b-a;  //降序排列
			})
21獲取數組元素索引==
		-indexOf(數組元素),從前面開查找指定的元素並返回數組元素的索引號,元素如有重覆時只返回第1個滿足條件的
		  索引號,如找不到該元素時返回-1
		-lastIndexOf(數組元素),從後面往前查找元素並返回元素的索引號,如找不到時返回-1
22數組去重==
		重要案例,加強練習
23數組轉換為字符串==
		1.toString():轉換後以逗號隔開
		2.join('分隔符'):未加參數時,默認使用逗號隔開,可以使用其他符號隔開ex:arr.join('-')或arr.join('&')
字符串對象==
24.對象才有屬性和方法,引用(複雜)數據類型才有屬性和方法,基本數據類型為何有length屬性?
	-基本包裝類型:就是將基本數據類型包裝成為引用數據類型
	var str='coca';
	console.log(str.length);//4-->基本數據類型為何有length屬性?因為它們執行了下列程序
	(1)把基本數據類型包裝為引用數據類型
		var temp=new String('coca');
	(2)把臨時變量的值賦值給str
	  str=temp;
	(3)銷毀這個臨時變量
		temp=null;
	JS提供三個特殊的引用類型:String,Number,Boolean
25.字符串的不可變性==
  	因為字符串的不可變性,指的是裏面的值不可變,雖然看上去改變內容了,但其實是地址變了,內存中又新開闢了
		一個內存空間,然後將新值放入,原來的字符串仍存在未消失,所以不要大量的拼接字符串
26.根據字符返回位置==
  	字符串所有的方法,都不會修改字符串本身(字符串是不可變的),操作完成會返回一個新的字符串
  	查詢字符串所在位置之索引值
		(1)indexOf('要查找的字符',[起始位置])  起始位置是索引值,從起始位置往後查找
		(2)lastIndexOf()從後面往前找 	
28.根據位置返回字符==
		1.charAt(index):根據位置返回字符,可用來遍歷字符串
		2.charCodeAt(index):會返回相應索引的字符ASCII值,目的:判斷用戶按下了那一個鍵
		3.str[index]:H5新增的
31.字符串方法==
		1.concat('字符串1','字符串2'...):用於連接兩個或多個字符串,作字符串拼接,實務上大多使用+
		2.substr(截取的起始位置start,截取長度length):截取字符串
32.替換字符、轉換為數組==
		1.replace('被替換的字符','替換為的字符'):它只會替換第一個字符
		2.split('分隔符'):取決於字符串中以何種分隔符隔開,將字符串轉換為數組==>join()把數組轉換為字符串,
數據類型總結==	
34基本數據類型:在存儲時變量中存儲的是值本身,因此又稱為值類型
	複雜數據類型:在存儲時變量中存儲的是地址(引用),因此又稱為引用數據類型
		-基本數據類型存於棧內存,存放的是值,
		-引用數據類型存於堆內存,首先在棧內存放地址(16進制),然後這個地址指向堆內的值
		-null-->返回的是一個空對象object
		-如變量打算存儲為對象,但暫時還没想好放啥,此時可先賦值為null
35基本數據類型傳參==
		函數的形參可視為一個變量,當把一個值類型變量作為參數傳給函數的形參時,其實是把變量在棧內存中的值複
		製一份給形參,因此在方法內部對形參做任何修改,均不影響外部變量
		function fn(a){
			a++;
			console.log(a);  //11
		}
		var x =10;
		fn(x);
		console.log(x);    //10
36引用數據類型傳參==
		函數的形參可視為一個變量,當我們把引用類型變量傳給形參時,其實是把變量在拡空間中保存的堆地址複製
		一份傳給了形參,形參和實參保存的是同一個堆地址,所以操作的同一個對象
		function Person(name){
			this.name=name;
		}
		function f1(x){
			console.log(x.name);       //劉德華
			x.name='張學友';
			console.log(x.name);			//張學友
		}
		var p=new Person('劉德華');
		console.log(p.name);        //劉德華      
		f1(p);
		console.log(p.name);				//張學友