02WEB APIs==
  -js組成:ECMA script基本語法、BOM、DOM(web APIs)
  -Web APIs是JS的應用,是W3C組織的標準,是JS獨有部份
03API和Web APIs==
  -API應用程序編程接口,是給程序員提供的一種工具,以便能更輕鬆實現想要完成的功能
  -Web API是瀏覽器提供的一套操作瀏覽器功能和頁面元素的API(BOM和DOM),主要針對瀏覽器做交互效果
05DOM簡介==Document Object Model
  -文檔對象模型(DOM)是W3C組織推薦的處理可擴展標記語言的標準編程接口,通過DOM接口可以改變網頁內容、結構和樣式
  -DOM樹Tree
    文檔:整個頁面就是一個文檔(document)
    元素:頁面中所有標籤都是元素(element)
    節點:網頁中所有內容都是節點(node),包含標籤、屬性、文本、注釋等。
    DOM將以上內容均視為對象(Object物件)
06獲取元素方法==
  1.根據ID獲取:使用getElementById()方法獲取帶有ID的元素對象
  2.根據標籤名獲取
  3.通過H5新增的方法獲取
  4.特殊元素獲取
  因為文檔頁面由上往下加載,所以將script寫在body標籤中
  使用getElementById('id')返回的是一個元素對象(Object物件)
  使用console.dir()可以返回元素對象及查看裏面的屬性和方法
07根據標籤名獲取元素==
 1.使用getElementsByTagName('div');
  (1)返回的是元素對象的集合,以偽數組形式存儲(arguments)
  (2)可通過遍歷方式獲取元素對象所有值
  (3)得到的元素對象是動態的-->內容改變JS不用變動
  (4)如果頁面中只有一個元素,返回的還是偽數組形式
  (5)如果頁面中没有這個元素,返回的空的偽數組形式
  (6)偽數組不可作為element
 2.也可以獲取某個元素(父元素)內部所有指定標籤名的子元素
    element.getElementsByTagName('標籤名');<--父元素必須是單個對象(必須指明是那一個元素對象),獲取時不包括父元素本身
    var ol =document.getElementsByTagName('ol');//[ol]
    console.log(ol[0].getElementsByTagName('li')) 或者使用
    //因為父元素需指明為元素對象,不可為偽數組,所以ol[0]
    var ol = document.getElementById('isol');
    console.log(ol.getElementsByTagName('li'));
08H5新增獲取元素方式==(IE9以上適用)
  1.透過class名來獲取元素
    document.getElementByClassName('類名')<--根據類名獲取元素返回元素對象集合(偽數組)
  2.透過選擇器來獲取元素,只能獲取第一個元素對象
    document.querySelector('選擇器')-->根據指定選擇器返回"第一個"元素對象,切記:裏面的選擇器需加符號如.box #nav
  3.返回指定選擇器的"所有元素"對象集合,可獲取全部選擇器的元素對象集合
    document.querySelectorAll('選擇器');-->與document.getElementsByTagName(div)或document.getElementByClassName(類名)類似
09獲取特殊元素(body.html)==
	1.獲取body元素
	  documnent.body  //返回body元素對象
	2.獲取html元素
	  document.documentElement //返回html元素對象
10事件三要素==
	事件簡單說就是用戶與電腦交互的行為,觸發--響應機制,由下列三部份組成(事件三要素)
	1.事件源:事件被觸發的對象(誰被觸發),如按鈕-->who對象(獲取事件源)
	2.事件類型:如何觸發,什麼事件,如鼠標點擊(onclick).鼠標經過.或鍵盤按下(做了什麼觸發事件)(綁定事件)
	3.事件處理程序:通過一個函數賦值的方式來完成(做什麼事情),(輸出部份)如彈出一個對話框
11執行事件的步驟==
	1.獲取事件源
	2.綁定事件
	3.添加事件處理程序(採取函數賦值形式)
12操作元素==
  JS的DOM操件可以改變網頁內容、結構和樣式,利用DOM操作元素來改變元素中的內容、屬性等
  1.改變元素內容
		(1)element.innerText:從起始位置到終止位置的內容,但它去除html標籤,同時空格和換行也會去掉
		(2)element.innerHTML(w3c):起始位置到終止位置的全部內容,包括html標籤,同時保留空格和換行
  2.操作常見元素屬性:src href title alt等
    
  3.操作表單元素屬性:type value disabled
  4.操作元素樣式屬性:
    (1)改變的樣式較少時直接使element.style
    (2)直接添加或修改className
13innerText和innerHTML區別==
		1.innerText不識別html標籤,非標準(IE專用),會去除空格和換行
		2.innerHTML可識別html標籤,W3C標準,保留空格和換行-->較常用
		這兩個屬性是可讀寫的,也可以獲取元素裏面的內容
14常用元素的屬性操作==
  1.透過修改src路徑改變顯示圖片
  2.修改title改變顯示內容
16修改表單屬性==
  1.表單中的文字內容是透過value來修改的
  2.某個表單被禁用,不能再被點擊,使用disabled
    ex:btn.disabled=true;  也可以使用this,這個this指向的是事件函數的調用者
17利用flag切換開關作法==仿京東password開關密碼
19樣式屬性操作==
  1.element.style-->修改行內樣式 如點擊修改樣式:如改變背景顏色、長寛、文字大小...
    注意樣式需採用駝峰命名法 fontSize  backgroundColor  且修改style樣式屬於行內樣式,css權重較高
  2.element.className-->修改類名樣式
21循環精靈圖
23使用className更改元素樣式==
  1.當樣式較多或功能較複雜時,可以透過修改或添加元素的className
  2.先將所需classname在style內寫好,當觸發事件時,將classname加到標籤中。
  3.注意樣式優先級問題
  4.當原先已有class時,如要保留原來class,可使用添加方式,就是在原有class後面再加一個新的class
26排他思想-->首先先排除其他人,然後再設置自己的樣式
  如果同一組元素,如要某一個元素實現某種樣式,則需要使用循環的排他思想,步驟有二
  1.先清除所有元素的全部樣式(幹掉其他人)
  2.再給當前元素設置樣式(留下我自己)
31自定義屬性操作1
  1.獲取屬性值
    (1)element.屬性 :獲取內建屬性值(元素本身自帶的屬性)
    (2)element.getAttribute('屬性'):獲取自定義屬性(程序員自己添加的屬性意即自定義屬性)
32自定義屬性操作2
  2.設置屬性值
    (1)element.屬性='值';  設置內建屬性值
    (2)element.setAttribute('屬性','值');主要針對自定義屬性
  3.移除屬性
    (1)element.removeAttribute('屬性');
36H5自定義性
  自定義屬性的目的:為了保存並使用數據,可以通過getAttribute('屬性')來獲取,但有些自定義屬性很容易
  引起歧義,不容易判斷是元素內建屬性還是自定義屬,所以H5規定自定義屬性均以data-開頭做為屬性名並賦值
  因此,我們自己設置自定義屬性時也遵循此一規範 設置時: element.setAttribute('data-屬性名',屬性值);
  獲取方式有二:
  1.element.getAttribute('屬性名');->無兼容性問題
  2.h5新增獲取自定義屬性:element.dataset.屬性名或 使用['屬性名']->IE11以上支持
    (1)dataset是一個集合,內存放了所有以data開頭的自定義屬性
    (2)如果自定義屬性裏面有多個單詞以-鏈接時,獲取時需採用駝峰命名法
37節點操作
  為什麼學習節點操作?->獲取元素,通常使用兩種方式
  1.利用DOM提供的方法獲取元素->缺點:繁瑣、邏輯性不強  ex:document.getElementById()...
  2.利用節點層級關係獲取元素
    (1)利用父子兄節點關係獲取元素
    (2)邏輯性強,但兼容性較差
  3.節點以node來表示,網頁頁面中所有內容均為節點,HTML DOM樹中的所有節點均可通過Javascript進行訪問
    所有HTML元素(節點)均可被創建、修改或刪除
    (1)節點有:nodeType(節點類型)、nodeName(節點名稱)和nodeValue(節點值)三個基本屬性
    (2)nodeType值元素節點:1  屬性節點:2  文本節點:3(文本節點含文字、空格、換行等)
    (3)節點操作主要是元素節點
38-39節點層級
  1.父節點:node.parentNode 獲取離元素最近的父級節點(親爸爸),如果找不到父節點則返回null
  2.子節點:
    (1)parent.childNodes 注意:獲取的是所有子節點,包含文本及元素等
    (2)parent.children 獲取所有的子元素節點(常用)
40獲取第一個子元素或最後一個子元素
    (1)獲取第一個子節點:parent.firstchild-->換行所以是#text
       獲取最後一個子節點:parent.lastchild-->也是換行所以也是#text
    (2)獲取第一個子元素:parentNode.firstElementChild
       獲取最後一個子元素:parentNode.lastElementChild
       有兼容性問題,IE9以上才支持
    (3)實際開發中使用方式:既無兼容性問題又可返回第一個子元素及最後一個元素
       獲取第一個子元素:parent.children[0]
       獲取最後一個子元素:ol.children[ol.children.length - 1]
42兄弟節點
  (1)nextSibling:獲取下一個兄弟節點,包含元素節點及文本節點等
     previousSibling:獲取上一個兄弟節點,包含元素節點及文本節點等
  (2)nextElementSibling:直接獲取下一個兄弟元素節點
     previousElementSibling:直接獲取上一個兄弟元素節點
      IE9以上兼容,解決方法自己封裝一個兼容性函數
     function getNextElementSibling(element){
       var el=element;
       while (el=el.nextSibling){
         if(el.nodeType===1){
           return el;
         }
       }
       return null;
     }
43創建節點
  1.語法: documnent.creatElement('tagName')  創建元素節點
    documnent.creatElement()方法創建由tagName指定的HTML元素,因為這些元素原先不存在,
    是根據需求動態生成的,所以也稱為動態創建元素節點。
  2.語法:node.appendChild(child)  添加子元素節點 node 父級  child 子級 是從後面追加元素,類似數組中的push
    此一方法是將一個節點添加到指定父節點的子節點列表末尾,類似css中的after偽元素
  3.語法:node.insertBefore(child,指定元素)
    此一方法是將一個節點添加到指定父節點的子節點列表前面,類似css中的before偽元素
    var lili =document.createElement('li');
    ul.insertBefore(lili,ul.children[0])
  總結:在頁面添加一個新的元素兩步驟:
    (1)創建元素:createElement
    (2)添加元素:appendChild(從最後面添加) 或 insertBefore(指定元素的前面)
45刪除節點
  node.removeChild(child) 此方法是DOM中刪除一個子節點,返回刪除的節點, node 父級  child 子級
46阻止鏈接跳轉使用javascript:;
47複製節點
  node.cloneNode()
  (1)如果括號參數為空或false,則為淺拷貝,只複製節點本身,不複製裏面的子節點
  (2)如果括號參數為true,則為深拷貝,會複製節點本身及裏面所有的子節點
48-53動態生成表格(重點案例多加練習)  
54-55三種動態創建元素區別
  1.document.write():是直接將內容寫入頁面的內容流,但原先的文檔流已加載完畢,所以它會導致頁面全部重新構建
  2.element.innerHTML:是將內容寫入某個DOM節點,不會導致頁面重繪,創建多個元素效率更高(但不要採取字符串拼接,
    而是採取數組形式拼接),結構稍微複雜
  3.document.createElement():創建多個元素效率稍低一點點,但結構較清晰
  總結:不同瀏覽下,innerHTML效率比createElement高
56DOM重點核心內容回顧
  1.DOM:文檔對象模型,是W3C推薦處理可擴展標記語言的標準編程接口,透過這些DOM接口可以改變網頁的內容、結構和樣式。
  2.對於Javascript,為了能够使javascript操作HTML,javascript就有了一套自己的DOM編程接口
  3.對於HTML,DOM使得HTML形成了一棵DOM樹,包含文檔、元素、節點。
  4.凡是獲取過來的DOM元素均是一個對象,因此稱為文檔對象模型(Document Object Model)
  對於DOM操作,主要針對元素進行創建、增刪改查,屬性操作及事件操作
  (1)創建
    1.document.write
    2.innerHTML
    3.createElement
  (2)增
    1.appendChild
    2.insertBefore
  (3)刪  removeChild
  (4)改:主要是修改DOM的元素屬性,DOM元素的內容、屬性、表單的值等。
    1.修改元素屬性:src  href   title等
    2.修改普通元素內容: innerHTML innerText
    3.修改表單元素:valus type disable
    4.修改元素樣式:style(行內樣式) className(樣式較多,添加或修改class)
  (5)查:主要是獲取查詢DOM的元素
    1.DOM提供的API方法:getElementById、getElementsByTagName等古老用法(不太推薦)
    2.H5新增的方法:querySelector、querySelectorAll (提倡)
    3.利用節點操作獲取元素:父(parentNode)、子(children)、兄(previousElementSibling  nextElementSibling)(提倡)
  (6)屬性操作:主要針對自定義屬性
    1.setAttribute:設置DOM的屬性值
    2.getAttribute:獲取DOM的屬性值
    3.removeAttribute:移除屬性
  (7)事件操作:主要是給元素綁定注冊事作,採取事件源、事件類型、事件處理程序三要素執行
    1.onclick:點擊
    2.onmouseover:鼠標經過
    3.onmouseout:鼠標離開
    4.onfocus:獲取鼠標焦點
    5.onblur:失去鼠標焦點
    6.onmousemove:鼠標移動
    7.onmouseup:鼠標彈起
    8.onmousedown:鼠標按下
57事件高級==============================================================================
58注冊事件(綁定事件)
  注冊事件區分為兩種:傳統方式及方法監聽注冊方式
  (1)傳統注冊事件:利用on開頭的事件,ex:onclick、onmouseover...具唯一性:同一個元素同一個事件只能設置一個處理函數,最後注
     冊的處理函數將會覆蓋前面注冊的處理函數。
  (2)方法監聽注冊方式:w3c標準,推薦方式,addEventLister()它是一個方法,IE9以前不支持此方法,可使用attachEvent()代替
     特點:同一個元素同一個事件可以添加多個監聽器,依注冊順序依次執行
     addEventListener事件監聽方式 語法:
     目標(監聽)對象.addEventListener(type,listener,[useCapture])->事件監聽方式
     1.type:事件類型字符串,ex:click、mouseover 注意不用加on,要加''號
     2.listener:事件處理函數,事件發生時,會調用該監聽函數 function()
     3.useCapture:可選參數,是一個布尔值,默認為false 
59.attachEvent('onclick',function(){})IE獨有,支持IE9以前-->直接使用傳統注冊事件方式即可取代
60.刪除事件(解綁事件)
  1.傳統解綁方式:
     btn.onclick=null;
  2.addEventListener-->removeEventListener('click', listener)
    注意:不可使用匿名函數,可利用函數關鍵字定義一個函數,然後listener再使用該函數名即可
61.DOM事件流:描述的是從頁中接收事件的順序,事件發生時會在元素節點之間按照特定的順序傳播,這個事件的傳播過程即DOM事件流
  區分為三個階段:捕獲階段(由上到下,由大到小)、當前目標階段、冒泡階段(由內往外,或由小到大)
  事件捕獲:網景最早提出,由DOM最頂層節點開始,然後逐級向下傳播到最具體的元素接收的過程(document->html->body->element)  
  事件冒泡:IE最早提出,事件開始時由最具體的元素接收,然後逐級向上傳播到DOM最頂層節點的過程(element->body->html->document)
62.DOM事件流注意事項
  1.JS代碼中只能執行捕獲或冒泡其中的一個階段
  2.onclick和attachEvent只能得到冒包階段
  3.addEventListener(tyoe,listener[,useCapture])第三個參數如果是true,表示在事件捕獲階段調用事件處理程序,
    如果是false,表示在事件冒泡階段調用事件處理程序
  4.實際開發中,較少使用事件捕獲,較關注事件冒泡階段
  5.有些事件是没有冒泡的,ex:onblur onfocus onmouseenter onmouseleave
  6.事件冒泡有時會帶來麻煩,有時又會很巧妙的做某些事件
63.事件對象***
  1.event就是一個事件對象,寫到監聽函數的小括號中,當形參使用
  2.事件對象只有有了事件才會存在,它是系統自動創建的,不需要傳遞參數
  3.事件對象是與事件一系列相關數據的集合,與事件相關的屬性和方法,ex:鼠標點擊內就包含了鼠標的相關信息(鼠標坐標等),
    如果是鍵盤事件內,就包含鍵盤事件的信息(如判斷用戶按下了那一個鍵)
    (1)傳統注冊事件:
     div.onclick=function(event){
       console.log(event);
     }
    (2)事件監聽方式:
     div.addEventListener('click',function(event){
       console.log(event);
     })
  4.這個事件對象可以自行命名,通常使用event  e  evt等...
  5.事件對象也有兼容性問題,IE678需使用window.event,可使用 e=e || window.event來解決
64.常見事件對象的屬性和方法
  1.target與this的區別: e.target 点击了那个元素，就返回那个元素,而 this 那个元素绑定了这个点击事件,那么就返回谁
    e.target 返回的是触发事件的对象（元素）
    this 返回的是绑定事件的对象（元素）