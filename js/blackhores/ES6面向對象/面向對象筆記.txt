02.兩大編程程序==
	1.面向過程(POP):依照分析好的步驟來解決問題,先分析解決問題所需步驟,再利用函數將這些步驟逐一實現,使用時再依序調用即可
		優點:性能比面向對高,適合與硬體相關的東西
		缺點:没有面向對象易維護、重用與擴展
	
	2.面向對象(OOP):將事務分解成一個個對象(找對象),然後在對象之間分工合作完成(搞對象),以對象的功能來劃分問題,而不是步驟
	  ,明確分工,較靈活代碼可重用,適合多人合作開發的大型軟件項目,具有三個特性:
		1.封裝性
		2.繼承性
		3.多態性:同一個對象在不同的時間可以呈現不同的狀態
		優點:易維護、重用與擴展,由於面向對象有封裝、繼承、多態等特性,可設計出低藕合的系統,使系統更加靈活與易於維護
		缺點:性能較面向過程低
	總結:兩者非互斥,而是互補,可以交互使用,一般簡單、步驟明確者使用面向過程,如果程序較複雜,多人合作大型開發項目使用面向對象

03.ES6中的類和對象==
	面向對象的思考模式:
	1.抽取對象中共同的屬性和行為封裝成一個類(或模板)
	2.針對類進行實例化,獲取類的對象
	面向對象編程應考慮對象有那些-->歸類劃分,創建對象,使用對象,指揮對象做事情
	-對象:(特定)現實生活中:萬物皆對象,對象是一個具體的事件,在JS中,對象是一組無序的相關屬性和方法的集合,所有的事都是對象,如字符串、數組、數值或函數等
		1.指一個具體的事物
		2.在JS中對象是一組相關屬性和方法的集合-->對象是由屬性和方法組成
		  屬性:事物的特徵,對象中的屬性常用名詞來表示
		  方法:事物的行為,在對象中的方法常用動詞來表示
	-類:在ES6中新增的概念,使用class關鍵字聲明一個類,使用這個類來實例化對象
		類-->抽取了對象的公共部份,它泛指某一大類(class),如明星,手機等
		對象-->特指某一個,通過類實例化一個具體的對象,如劉德華,張學友,這支蘋果手機等

04.ES6中創建類和生成實例==
	-創建類  
	 語法:  
	  class Star{
		//將類中的公共屬性放到constructor中,constructor()方法是類的構造函數(默認方法),用於傳遞參數,返回實例對象,通過new命令生成對象時,
	    自動調用該方法,如果没有顯示定義,類內部會自動給我們創建一個constructor()
			constructor(uname,uage)	{
				this.name=uname;  //this指向的新創建的對象實例
				this.age=uage;
			}						 //多個函數方法之間不需要加逗號分隔,	
			sing(song){  //類中的創建方法
				console.log(song)
			}
	  }
		var ldh = new Star('劉德華',36); //透過Star類創建一個ldh對象,具有name和age兩個屬性
		var zxy = new Star('張學友',40); 
		console.log(ldh.name);//劉德華
		console.log(zxy.name);//張學友
		ldh.sing('冰雨');//調用方法-->冰雨
		zxy.sing('李香蘭');//調用方法-->李香蘭
 		
	-創建實例:
	  var xx = new name(); 類必須使用new實例化對象
	-注意事項:
		1.通過class關鍵字創建類,類名習慣性定義首字母大寫
		2.類中有個constructor函數,可接受傳遞過來的參數,同時返回實例對象,所以不用return
		3.constructor函數只要new生成實例時,就會自動調用這個函數,如不寫這個函數,類也會自動生成這個函數
		4.生成實例時new不能省略
		5.創建類時,類名後面不要加小括號,生成實例時,類名後面要加小括號,構造函數不需加function

05.類中添加方法== 	
	1.在類中添加方法時,所有的函數不需要寫function,直接使用 方法名(){功能}即可
	2.多個函數方法之間不需要添加,逗號分隔
	3.調用方法:  對象.方法(實參)

06.類的繼承==extends和super
	1.子類可繼承父類的一些屬性和方法。
	2.子類使用extends來繼承父類的屬性和方法
  	ex:  class Son extends Father{}
	3.使用super關鍵字來訪問和調用父類上的函數,除了父類的構造函數外,也可調用父類的普通函數

07.super調用父類普通函數原則==
	繼承中的屬性和方法查找原則:就近原則
	1.繼承中,如果實例化子類輸出一個方法,先看子類有没有這個方法,如果有就先執行子類的
	2.如果子類中没有這個方法,就去查找父類有没有這個方法,如果有,則執行父類的這個方法(採用就近原則)
	3.配合使用super關鍵字可以調用父類的普通函數

08.子類可以繼承父類的加法方法,同時也可擴展自己的減法方法-->注意點:super必須放到子類this之前
	利用super調用父類的構造函數時,super必須在子類this之前調用,意即必須先調用父類的構造方法再使用子類構造方法

09.使用類三個注意點
	1.在ES6中,類没有變量提升,所以必須先定義類,才能通過類實例化對象
	2.類裏面的共有的屬性和方法一定要加this使用。 
	3.類裏面的this指向問題
	4.constructor中的this指向的是創建的實例化對象
	  方法中的this指向的是這個方法的調用者,誰調用this指向誰
	  
10.tab選項卡案例
91.ES6簡介:ECMAScript ES6實際上是一個泛指,泛指ES2015及後續的版本,它是ECMA國際標準化組織制定的
   一項腳本語言的標準化規範
	 為什麼使用ES6?每一次標準的誕生都意味著語言的完善,功能的加強,JS語言本身也有一些令人不滿意的地方如:
	 1.變量提升特性增加了程序運行時不可預測性
	 2.語法過於鬆散,實現相同的功能,不同的人可能會寫出不同的代碼
92.let-->主要是用來替代var關鍵字  
	 1.ES6中新增用於聲明變量的關鍵字
	 2.let聲明的變量只在所處塊級作用域{}有效
		 好處:
		 (1)防止內部的變量覆蓋外部的變量		
		 (2)防止循環變量變成全局變量
				for (var i=0;i<2;i++){
				}
				console.log(i);  //2
				for (let i=0;i<2;i++){
				}	
				console.log(i);  //i is not defined
	 3.let和var最大區別:使用let關鍵字聲明的變量才具有塊級作用域,使用var聲明的變量不具有塊級作用域的特性
		 if (true){
		 	let num=10;
		 	var abc=20;
		 	}
		 console.log(num);  //num not defined
		 console.log(abc);  //20
	 4.使用let聲明的變量没有變量提升	
		 console.log(a);  //a is not defined
		 let a=10;
	 5.使用let聲明的變量具有暫時性死區的特性
		 var num=10;
		 if (true){
			 console.log(num);  //num is not defined
			 let num=20;
		 }
96.每次循環都會產生一個塊級作用域,每個塊級作用域中的變量都是不同的,當函數時執行時輸出的是自己上一級(循環產生
   的塊級作用域)作用域下的值。
97.const:作用是用來聲明常量(數),常量就是值(內存地址)不會變化的量,特點:
	1.具有塊級作用域		
	2.聲明常量時必須賦初始值,否則報錯
	3.常量賦值後,值不可修改,意即內存地址不可更改(基本數據類型),但複雜數據類型如array數組
	  const arry = [100,200];
		arry[0]=123;  //ok
		arry=[1,2];  //報錯,更改內存地址
100.let  const  var 的區別
	1.使用var聲明的變量,其作用域為該語句所在的函數內(函數作用域),且存在變量提升現象
	2.使用let聲明的變量,其作用域為該語句所在的代碼塊{}內(塊級作用域),不存在變量提升現象
	3.使用const聲明的是常量(塊級作用域),在後面出現的代碼中不可再修改該常量的值
101.解構賦值:ES6中允計從數組中提取值,按照對應位置,對變量賦值,對象也可以實現解構。
	1.數組解構:
		let [a,b,c]=[1,2,3];  let a=1,b=2,c=3; 
		console.log(a);  //1
		console.log(b);  //2
		console.log(c);  //3
	2.對象解構:允許我們使用變量的名字匹配對象的屬性,匹配成功,將對象屬性的值賦值給變量
	  let person = {name: 'lisi', age: 30, sex: '男'};
		let { name, age, sex } = person;
		console.log(name)  //lisi
		console.log(age)   //30
		console.log(sex)   //男
		另一種寫法
		let person = {name: 'lisi', age: 30, sex: '男'};
		let {name: myName} = person;  name是用來匹配person對象中的name屬性,匹配成功,則將屬性值lisi賦值給myName變量
		console.log(myName)
104.箭頭函數:ES6中新增的用來簡化函數定義語法
		() => {}   ()用來定義形參  {函數體}  內包含函數體
	1.函數體中只有一句代碼,且代碼的執行結果就是返回值,則可省略大括號
		const sum = (n1, n2) => n1 + n2;	 
		const result = sum(10, 20);
		console.log(result);  //30
	2.如果形參只有一個,可以省略小括號
	  const fn = v => {
	  	alert(v);
	  }
	  fn(20);  //20
105.箭頭函數不綁定this關鍵字,箭頭函數中的this,指向的是函數定義位置的上下文this

107.剩餘參數:當實參個數大於形參個數時,可將形參放置在一數組中,利用...args來接收剩餘參數,
    語法允許我們將一個不定數量的參數表示為一個數組
		function sum (first, ...args){
			console.log(first);  //10
			console.log(args);   //[20,30]
		}
		sum(10,20,30);
108.剩餘參數與解構配合使用
    let ary1 = ['张三', '李四', '王五'];
		let [s1, ...s2] = ary1;
		console.log(s1)   //s1=張三
		console.log(s2)  //s2=數組['李四', '王五']
109.擴展運算符(展開語法)-->Array的擴展方法
		擴展運算符可以將數組或對象轉為以逗號分隔的參數序列
		let ary =[1,2,3];
		console.log("1","2","3")  //1 2 3
		console.log(...ary)  //1 2 3
110.擴展運算符可應用於合併數組
		方法一:
		let ary1 = [1, 2, 3];
		let ary2 = [4, 5, 6];
		// ...ary1 // 1, 2, 3
		// ...ary2 // 4, 5, 6
		let ary3 = [...ary1, ...ary2];
		console.log(ary3)
		方法二:使用push()方法將ary2合併到ary1中  ary1.push(...ary2)