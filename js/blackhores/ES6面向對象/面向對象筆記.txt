02.兩大編程程序==
	1.面向過程(POP):依照分析好的步驟來解決問題,先分析解決問題所需步驟,再利用函數將這些步驟逐一實現,使用時再依序調用即可
		優點:性能比面向對高,適合與硬體相關的東西
		缺點:没有面向對象易維護、重用與擴展
	
	2.面向對象(OOP):將事務分解成一個個對象(找對象),然後在對象之間分工合作完成(搞對象),以對象的功能來劃分問題,而不是步驟
	  ,每一個對象都是功能中心,明確分工,較靈活,代碼可重用,適合多人合作開發的大型軟件項目,具有三個特性:
		1.封裝性
		2.繼承性
		3.多態性:同一個對象在不同的時間可以呈現不同的狀態
		優點:易維護、重用與擴展,由於面向對象有封裝、繼承、多態等特性,可設計出低藕合的系統,使系統更加靈活與易於維護
		缺點:性能較面向過程低
	總結:兩者非互斥,而是互補,可以交互使用,一般簡單、步驟明確者使用面向過程,如果程序較複雜,多人合作大型開發項目使用面向對象

03.ES6中的類和對象==
	面向對象的思考模式:
	1.抽取對象中共同的屬性和行為封裝成一個類(或模板)
	2.針對類進行實例化,獲取類的對象
	面向對象編程應考慮對象有那些-->歸類劃分,創建對象,使用對象,指揮對象做事情
	-對象:(特定)現實生活中:萬物皆對象,對象是一個具體的事件,在JS中,對象是一組無序的相關屬性和方法的集合,所有的事都是對象,如字
	 符串、數組、數值或函數等
		1.指一個具體的事物
		2.在JS中對象是一組相關屬性和方法的集合-->對象是由屬性和方法組成
		  屬性:事物的特徵,對象中的屬性常用名詞來表示
		  方法:事物的行為,在對象中的方法常用動詞來表示
	-類:在ES6中新增的概念,使用class關鍵字聲明一個類,使用這個類來實例化對象
		類-->抽取了對象的公共部份,它泛指某一大類(class),如明星,手機等
		對象-->特指某一個,通過類實例化獲取類的對象(一個具體的對象),如劉德華,張學友,這支蘋果手機等

04.ES6中創建類和生成實例==
	第1步-創建類  語法: class Star{  }
	第2步-利用new關鍵字創建實例化對象  使用new創建對象 new  Star()
		1.將類中的公共屬性(如:姓名、年齡、性別...)等放到constructor()中
		2.constructor()方法是類的構造函數(默認方法),用於傳遞參數,返回實例對象,通過new命令生成對象時,
	    自動調用該方法,如果没有顯示定義,類內部會自動給我們創建一個constructor()
			constructor(uname,uage)	{  //共同屬性:姓名、年齡、性別...等
				this.name=uname;  //this指向的新創建的實例對象
				this.age=uage;
			}						 //多個函數方法之間不需要加逗號分隔,	
			sing(song){  //類中的創建方法
				console.log(song)
			}
	  }
		var ldh = new Star('劉德華',36); //透過Star類創建一個ldh對象,具有name和age兩個屬性
		var zxy = new Star('張學友',40); 
		console.log(ldh.name);//劉德華
		console.log(zxy.name);//張學友
		ldh.sing('冰雨');//調用方法-->冰雨
		zxy.sing('李香蘭');//調用方法-->李香蘭
 		
	-創建實例:
	  var xx = new name(); 類必須使用new實例化對象
	-注意事項:
		1.通過class關鍵字創建類,類名習慣性定義首字母大寫
		2.類中有個constructor函數,可接受傳遞過來的參數,同時返回實例對象,所以不用return
		3.constructor函數只要new生成實例時,就會自動調用這個函數,如不寫這個函數,類也會自動生成這個函數
		4.生成實例時new不能省略
		5.創建類時,類名後面不要加小括號,生成實例時,類名後面要加小括號,構造函數不需加function

05.類中添加方法== 	
	1.在類中添加方法時,所有的函數不需要寫function,直接使用 方法名(){功能}即可
	2.多個函數方法之間不需要添加,逗號分隔
	3.調用方法:  對象.方法(實參)

06.類的繼承==extends和super
	1.子類可繼承父類的一些屬性和方法。
	2.子類使用extends來繼承父類的屬性和方法
  	ex:  class Son extends Father{}
	3.使用super關鍵字來訪問和調用父類上的函數,除了父類的構造函數外,也可調用父類的普通函數

07.super調用父類普通函數原則==
	繼承中的屬性和方法查找原則:就近原則
	1.繼承中,如果實例化子類輸出一個方法,先看子類有没有這個方法,如果有就先執行子類的
	2.如果子類中没有這個方法,就去查找父類有没有這個方法,如果有,則執行父類的這個方法(採用就近原則)
	3.配合使用super關鍵字可以調用父類的普通函數

08.子類可以繼承父類的加法方法,同時也可擴展自己的減法方法-->注意點:super必須放到子類this之前
	利用super調用父類的構造函數時,super必須在子類this之前調用,意即必須先調用父類的構造方法再使用子類構造方法

09.使用類三個注意點
	1.在ES6中,類没有變量提升,所以必須先定義類,才能通過類實例化對象
	2.類裏面的共有的屬性和方法一定要加this使用。 
	3.類裏面的this指向問題
	4.constructor中的this指向的是創建的實例化對象
	  方法中的this指向的是這個方法的調用者,誰調用this指向誰
	  
10.tab選項卡案例

24.構造函數和原型
	1.概述:在典型的OOP的語言中(如Java),都存在類(class)的概念,類就是對象的模板,對象就是類的實例,但在ES6以前,JS中尚未
	      引入類的概念,在ES6以前,對象不是基於類創建的,而是用一種稱為構造函數來定義對象和它們的特徵。
	2.創建對象三種方式:
		(1)對象字面量: var obj={};
		(2)使用new Objecr(): var obj1=new Object();
		(3)自定義構造函數:function Star(uname,uage){
					this.uname=uname;
					this.uage=uage;
					this.sing=function(){
						console.log('我會唱歌');
					}
				}
				var ldh =new Star('劉德華',18);  //創建劉德華對象
				console.log(ldh);
				ldh.sing();
	3.構造函數:是一種特殊的函數,主要用來初始化對象,即為對象成員變量賦予初始值,它總與new一起使用,經常將對象中的一些公共
		屬性和方法抽取出來,然後封裝到這個函數中,在JS中,使用構造函數時要注意以下兩點:
		(1)構造函數用於創建某一類對象,首字母要大寫。
		(2)構造函數要和new一起使用才有意義
		new在執行時會做四件事情:
		(1)在內存中創建一個新的空對象
		(2)讓this指向這個新的對象
		(3)執行構造函數中的代碼,給這個新對象添加屬性和方法
		(4)返回這個新對象(所以構造函數中不需要return)
25.構造函數中的屬性和方法稱之為成員,成員可以添加
		(1)靜態成員:在構造函數本身上添加的成員,如Star.sex='男',sex即為靜態成員,只能通過構造函數來訪問,如Star.sex,不能通過對象來訪問
	  (2)實例成員:就是在構造函數內部通過this添加的成員(如uname,age,sing),實例成員只能通過實例化的對象來訪問,不可以通過
		   構造函數來訪問實例
26.構造函數原型對象prototype
	構造函數的問題:存在浪費內存的問題,我們希望所有的對象使用同一個函數,這樣就比較節省內存,該如何做?==>使用構造函數原型prototype
	構造函數通過原型分配的函數是所有對所共享的,在JS中規定,每個構造函數都有一個prototype屬性,指向另一個對象,注意這個prototype就是一
	個對象,這個對象的所有屬性和方法,都會被構造函數所擁有,可將那些不變的方法,直接定義在prototype對象上,這樣所有對象的實例就可以共享這
	些方法。
	原型:一個對象,也稱之為prototype為原型對象,原型的作用是共享方法,一般情況,將公共屬性定義到構造函數中,公共的方法則放到原型對象中
27.對象原型__proto__:對象都會有一個屬性__proto__指向構造函數的prototype原型對象,之所以我們對象可以使用構造函數prototype原型對象
  的屬性和方法,就是因為對象有__proto__原型的存在(對象身上系統會自己自動添加一個__proto__指向我們構造函數的原型對象),意即prototype
	(1)對象原型和原型對象prototype是等價的(ldh.__proto===Star.prototype)
	(2)__proto__對象原型的意義就在於為對象的查找機制提供一個方向,或者說一條路線,但是它是一個非標準屬性,因此實際開發中,不可使用這個屬
	   性,它只是內部指向原型對象prototype
28.constructor構造函數
	對象原型(__proto__)和構造函數(prototype)原型對象中都有一個constructor屬性,constructor稱之為構造函數,因為它指回構造函數本身
	constructor主要用於紀錄該對象引用於那個構造函數,它可以該原型對象重新指向原來的構造函數
	如果我們修改了原來的原型對象,給原型對象賦值的是一個對象,則必須手動的利用constructor指向原來的構造函數
29.構造函數、實例、原型對象三者之間的關係
	構造函數通過prototype屬性指向原型對象prototype,而原型對象prototype則通過constructor屬性又指回原來的構造函數
	構造函數可以通過對象實例化創建實例化對象,而實例化對象中均有一個__proto__屬性指向原型對象prototype
30.原型對象prototype中也有一個原型__proto__,它指向Object的原型對象,而Object原型對象prototype的__proto__原型為null
	稱之為原型鏈
	
91.ES6簡介:ECMAScript ES6實際上是一個泛指,泛指ES2015及後續的版本,它是ECMA國際標準化組織制定的
   一項腳本語言的標準化規範
	 為什麼使用ES6?每一次標準的誕生都意味著語言的完善,功能的加強,JS語言本身也有一些令人不滿意的地方如:
	 1.變量提升特性增加了程序運行時不可預測性
	 2.語法過於鬆散,實現相同的功能,不同的人可能會寫出不同的代碼
92.let-->主要是用來替代var關鍵字  
	 1.ES6中新增用於聲明變量的關鍵字
	 2.let聲明的變量只在所處塊級作用域{}有效
		 好處:
		 (1)防止內部的變量覆蓋外部的變量		
		 (2)防止循環變量變成全局變量
				for (var i=0;i<2;i++){
				}
				console.log(i);  //2
				for (let i=0;i<2;i++){
				}	
				console.log(i);  //i is not defined
	 3.let和var最大區別:使用let關鍵字聲明的變量才具有塊級作用域,使用var聲明的變量不具有塊級作用域的特性
		 if (true){
		 	let num=10;
		 	var abc=20;
		 	}
		 console.log(num);  //num not defined
		 console.log(abc);  //20
	 4.使用let聲明的變量没有變量提升	
		 console.log(a);  //a is not defined
		 let a=10;
	 5.使用let聲明的變量具有暫時性死區的特性
		 var num=10;
		 if (true){
			 console.log(num);  //num is not defined
			 let num=20;
		 }
96.每次循環都會產生一個塊級作用域,每個塊級作用域中的變量都是不同的,當函數時執行時輸出的是自己上一級(循環產生
   的塊級作用域)作用域下的值。
97.const:作用是用來聲明常量(數),常量就是值(內存地址)不會變化的量,特點:
	1.具有塊級作用域		
	2.聲明常量時必須賦予初始值,否則報錯。
	3.常量賦值後,值不可修改,意即內存地址不可更改(基本數據類型),但複雜數據類型如array數組
	  const arry = [100,200];
		arry[0]=123;  //值可更改[123,200]
		arry=[1,2];  //重新賦值時會報錯,更改內存地址
100.let  const  var 的區別
	1.使用var聲明的變量,其作用域為該語句所在的函數內(函數作用域),且存在變量提升現象,值可更改
	2.使用let聲明的變量,其作用域為該語句所在的代碼塊{}內(塊級作用域),不存在變量提升現象,值可更改
	3.使用const聲明的是常量(塊級作用域),在後面出現的代碼中不可再修改該常量的值
101.解構賦值:分解數據結構,ES6中允許從數組中提取值,按照一一對應的位置,對變量賦值,對象也可以實現解構。
	1.數組解構:
		let [a,b,c]=[1,2,3];  let a=1,b=2,c=3; 等號左邊的[]代表數組解構,從數組中提取一一對應的值,再將值賦值給變量,
		如變量數目大於等號右邊的值時,會產生未賦值情況,呈現undefined
		console.log(a);  //1
		console.log(b);  //2
		console.log(c);  //3
	2.對象解構:等號左邊使用大括號表示對象解構,允許我們使用變量的名字匹配對象的屬性,匹配成功,將對象屬性的值賦值給變量
	  let person = {name: 'lisi', age: 30, sex: '男'};
		let { name, age, sex } = person;  對象解構 person.name 
		console.log(name)  //lisi
		console.log(age)   //30
		console.log(sex)   //男
		另一種寫法
		let person = {name: 'lisi', age: 30, sex: '男'};
		let {name: myName} = person;  name是用來匹配person對象中的name屬性,匹配成功,則將屬性值lisi賦值給myName變量
		console.log(myName)
104.箭頭函數:ES6中新增的用來簡化函數定義語法
		語法: () => {}   ()用來定義形參  {函數體}  內包含函數體
		const fn = () =>{  將箭頭函數賦值給fn常數  或使用let fn變量
			console.log(123)
		}
		fn()
	箭頭函數特性:
	1.函數體中只有一句代碼,且代碼的執行結果就是返回值,則可省略大括號
		const sum = (n1, n2) => n1 + n2;	//此處省略{}及return 
		const result = sum(10, 20);
		console.log(result);  //30
		相當於下面的函數
		function sum(n1,n2){
			return n1+n2;
		}	
		console.log(sum(10,20)); //30
	2.如果形參只有一個,可以省略小括號
	  const fn = v => v ;
	  fn(20);  //20
		相當於下面的函數
		function fn(x){
			return x;
		}
		console.log(fn(10));//10
105.箭頭函數不綁定this關鍵字,它没有自己的this關鍵字,箭頭函數中的this,指向的是函數定義位置的上下文this
		function fn(){
			console.log(this); // {name:'張三'}
			return () => {
				console.log(this)  // {name:'張三'}
			}
		}
		const obj = {name:'張三'};
		const resFn = fn.call(obj);
		resFn();
106.箭頭函數面試題:
		var obj={
			age:20,
			say:()=>{   //箭頭函數中的this指向的是函數定義位置中的對象,而obj不能產生作用域,因此為window全局作用域
				alert(this.age)  //this指向的是window,而window下没有age屬性,所以obj.say()得到的結果是undefined
			}
		}
		obj.say();  //undefined
107.剩餘參數:當實參個數大於形參個數時,可將剩餘形參放置在一數組中,利用...args來接收剩餘參數,
    語法允許我們將一個不定數量的參數表示為一個數組
		在箭頭函數中無法使用arguments,但可以使用...args剩餘參數來接收數量不定的形參
		function sum (first, ...args){
			console.log(first);  //10
			console.log(args);   //[20,30]
		}
		sum(10,20,30);

		const sum = (...args) => {
			let total = 0;
			args.forEach(item => {   //大括號可以省略 forEach(item => total += item)  
				total += item;
			})
			return total;         //forEach循環數組
		}
		console.log(sum(10.20)); //30
		console.log(sum(10,20,30)) //60
108.剩餘參數與解構配合使用
    let ary1 = ['张三', '李四', '王五'];
		let [s1, ...s2] = ary1;
		console.log(s1)   //s1='張三'
		console.log(s2)  //s2=['李四', '王五'] 數組解構,s2成為數組同時接收['李四','王五']
109.Array的擴展方法:
  1.擴展運算符(展開語法),與剩餘參數(將剩餘的參數放在一個數組中)相反
		擴展運算符可以將數組或對象轉為以逗號分隔的參數序列
		let ary =[1,2,3];
		console.log(...ary)  //1 2 3 與下面的代碼相同
		console.log("1","2","3")  //1 2 3 
110.擴展運算符可應用於合併數組
		方法一:
		let ary1 = [1, 2, 3];
		let ary2 = [4, 5, 6];
		// ...ary1 // 1, 2, 3
		// ...ary2 // 4, 5, 6
		let ary3 = [...ary1, ...ary2];//將ary1和ary2數組合併成ary3 = [1,2,3,4,5,6]
		console.log(ary3)  [1,2,3,4,5,6]		
		方法二:使用push()方法將ary2合併到ary1中  ary1.push(...ary2)
112.將類數組或可遍歷對象轉換為真正的數組
	let oDivs=document.getElementsByTagName('div);  //oDivs為偽數組
	var ary = [...oDivs];  利用擴展運算符將偽數組轉換為真正的數組,好處:即可使用數組的方法,如push
113.array.from方法
114.find()方法:用於找出第一個符合條件的數組成員,如果没有找到則返回undeined
115.findIndex()方法:用於找出第一個符合條件的數組成員的位置,如果没有找到則返回-1
116.includes()方法:表示某個數組是否包含給定的值,返回true 或false  ==>ES6以前使用indexOf
117.String擴展方法:
	1.模板字符串:ES6新增的創建字符串的方式,使用反引號定義之。
		特點:
		(1)可以解析變量,使用${變量名}來取代字符串拼接
		(2)模板字符串可以換行
		(3)在模板字符串中可以調用函數
	2.startsWith():表示參數字符串是否以某字符串開頭,返回布林值
	  endsWith():表示參數字符串是否以某字符串結尾,返回布林值
	3.repeat()方法:表示將原字符串重複n次,返回一個新字符串  原字符串.repeat(n)  'a'.repeat(2) //aa
120.Set數據結構:ES6中的新的數據結構Set,它類似於數組,但成員的都是唯一的,没有重複的值,主要應用於搜索關
    鍵字,利用值不重複特性,來存儲關鍵字
		Set本身是一個構造函數,用來生成Set數據結構,有一內建屬性size,存儲數據個數
121.利用Set作數組去重
122.數據操作:
	add(value):添加某個值,返回Set結構本身
	delete(value):刪除某個值,返回一個布林值,表示刪除是否成功
	has(value):判斷該值是否為Set的成員,返回一個布林值
	clear():清除所有成員,没有返回值  
123.遍歷:從中取值 使用forEach()方法    

		


