### 05.javascript 簡介

- 編程語言，控制人與計算機之間交互的行為
- javascript 是一種運行在客戶端的腳本語言，不需要編譯，而是由 js 解釋器(js 引擎)進行解釋並執行

- 作用：

  1. 表單驗證
  2. 網頁特效
  3. 服務端開發(node.js)
  4. 桌面程序
  5. App
  6. 控制硬體-物聯網(Ruff)
  7. 游戲開發...

### 06.瀏覽器分成兩部份：渲染引擎和 JS 引擎

- 渲染引擎：用來解析 HTML 與 CSS，俗稱內核，chrome 的 blink
- JS 引擎：JS 解析器，用來讀取解析網頁中的`Javascript` 代碼，如 chrome 瀏覽器的 V8
- JS 引擎執行代碼解析時係逐行解釋每一句源碼，然後由計算機去執行，所以`Javascript`語言歸類為腳本語言，會逐行解釋執行。

### 07.JS 組成

JS 包含三部份：ECMAScript(JS 基礎語法)、BOM、DOM(Web API)

1. ECMASscript 規定 JS 的編程語法和基礎核心知識，是所有瀏覽器廠商共同遵守的一套 JS 語法工業標準。

2. DOM-文檔對象模型(Document Object Model)

3. BOM-瀏覽器對象模型(Browser Object Model)：通過 BOM 可操作瀏覽器窗口，如彈出框、控制瀏覽器跳轉、獲取分辨率等。

### 08.編寫位置

1. 行內 JS--直接寫到元素的內部
2. 內嵌式 JS--在 head 中使用`<script></script>`中間有個空格

3. 外部 JS--在 head 中使用`<script src="demo.js"></script>`引入 js 文件，在`<script>`之間不可再寫代碼

### 09.注釋

    // 單行注釋  ctrl+/
    /* 多行注釋 */   ctrl+shift+/

### 10.輸入輸出框

- `prompt('請輸入1-10數字')` ->輸入框
- `console.log()` ->輸出到控制台
- `alert()` ->彈出框

### 12.變量

- 變量用於存放數據的容器，通常通過變量名來獲取數據，甚至數據可以修改，本質上是程序在內存中開闢一塊用來存放數據的空間

- 使用步驟：

  1. 使用`var`聲明變量：var 變量名 　->　在內存中開闢一個空間

  2. 賦值 `name=10;`

- 變量初始化：聲明變量同時賦值 `var myName=10;`

### 16.變量語法擴展

1. 更新變量：一個變量被重新賦值後，它原有的值就會被覆蓋掉，變量值會以最後一個賦值為準。

2. 同時聲明多個變量：每個變量之間以逗號隔開 var age=18，myname='coca';

3. 只聲明不賦值：結果為 undefined(未定義)

4. 未聲明且不賦值：結果是報錯

5. 不聲明直接賦值：成為全局變量，如`num=10;`

### 17.變量命名規範

1. 區分大小寫，不可以數字開頭，不可使用關鍵字或保留字

2. 變量名可見名思義，以駝峰命名法開頭小寫後面單詞的首字母大寫

3. 可使用英文字母，數字、下劃線、美元符$

### 18.交換變量值

利用空的臨時變量(temp)

```js
var temp;
var num1 = 10,
  num2 = 20;
temp = num1;
num1 = num2;
num2 = temp;
```

### 21.數據類型簡介

- js 是一種弱類型語言，意味著不用提前聲明變量的類型，在程序運行過程中，根據等號右邊的值的類型來確認。
- js 屬於動態語言，變量的數據類型是可以變化的，相同的變量可作不同類型的轉換，以最後一個賦值為主。

### 22.數據類型分類

- 基本數據類型：Number、Boolean、String、Null、Underfined
- 複合數據類型：Object
- 八進制 --> 0~7
- 十六進制 -->0~9 a~f 0x 開頭
- 數字型的最大值 Number.MAX\*VALUE
- 數字型的最小值 Number.MIN_VALUE
- 無窮大 -->Infinity
- 無窮小 -->-Infinity
- NAN -->非數字

### 23.isNaN()

- 通常用來驗證用戶輸入值是否為數字型
- isNaN()-->用來判斷值是否為非數字
  true：是非數字
  false：是數字

### 24.字符串 String

- 加單引號或雙引號者，嵌套時外雙內單
- 轉義字符：用\開頭 ex-->\n：換行 \\：斜摃 \\b：空格 \t：tab 縮進

### 26.字符串長度與拼接

- 檢查並獲取字符串長度時，使用 length 屬性
  `ex： var str='my name is andy';`
  `console.log(str.length); //15`
- 字符串拼接：使用+進行拼接，字符串+任何類型=拼接之後的新字符串，任何數據類型與字符串相加時為字符串拼接
- "+"號口訣：數值相加，字符相連
- 變量和字符串相連的口訣-->引引加加

### 29.布林 Boolean 型

- 有兩個值：true(真)和 false(假)
- true 参與加法運算時當 1 來看、false 参與加法運算當 0 來看
- 如果一個變量聲明未赋值，就是 undefined 未定義數據類型， undefined 和數字相加，最後的结果是 NaN
- null 空值

### 30.獲取數據類型

- 使用 typeof 檢查數據類型 `console.log(typeof null) //object`
- 使用 prompt()取出來的值是字符串類型，如要數值運算時需執行數據類型轉換

### 31.字面量(常量、常數)

字面量：固定值的表示法

- 數字字面量：8，9，10
- 字符串字面量：'程序員'，'前端'
- 布林字面量：true、false

### 32.數據類型轉換：

將一種數據類型的變量轉換成另一種數據類型，方便後續操作使用

- 轉成字符串類型

  1. toString()-->變量.toString()

  2. String()-->函數 String(變量)

  3. 加號拼接字符串-->變量+''(空字符串)-->隱式轉換

- 轉成數值類型

  1. parseInt(變量) ->函數->將 string 類型轉成整數數值類型(取整，不會四捨五入進位，由左往右取，遇非數值時就停止)

  2. parseFloat(string)->函數->將 string 類型轉成整數或浮點數數值類型(取整或取小數點)

  3. Number(變量)強制類型轉換->函數->將 string 類型轉成數值類型

  4. js 隠式轉換(- \* /)-->利用運算式進行隠式轉換為數值 (-0 \_1 /1)

     - `console.log('12' - 0); // 12`
     - `console.log('123' - '120');`
     - `console.log('123' * 1);`

- 轉成 Boolean()
  使用 Boolean()函數， 0 NaN null undefind -->均轉成 false，其餘值均轉成 true

### 38.解釋型語言與編譯型語言

Java 為編譯型語言，會整個編譯後產生新的文件；Javascript 為解釋型語言，逐行解釋並立即執行

### 42.運算符(操作符)

用來實現賦值、比較和執行算運算等功能的符號

- 包括算術、比較、邏輯、賦值、遞增(減)
- 不要直接使用浮點數作為比較判斷是否相等-->浮點數會有精確度問題
- 整除-->使用%取餘

### 43-47.表逹式與返回值

- 表逹式：由數字，運算符，變量等組成的式子
- 返回值：將右邉表逹式運算結果返回給左邉的變量，所有表逹式均會有一個結果返回給我們，稱之為返回值

### 44.遞增遞減

- ++變量-->前置自增(先自增，後返回值)
- 變量++-->後置自增(先返回原值，後自增)
- 前置自增和後置自增如果單獨使用時，效果相同

### 48.比較(關係)運算符

- 會返回布林值(true false)
  - = 賦值，將右邊給左邊
  - == 判斷是否相等-->會轉換類型，只要求值是否相等
  - === 全等-->不會轉換類型，包含值和類型是否全都相同

### 49.邏輯運算符

- 也是會返回布林值(true、false)
  && 與 -->and-->找 false(只要為第一個表逹式返回值為 false 時即返回 false，如為 true 再進行第二個表逹式判斷)
  || 或 -->or -->找 true (只要為第一個表逹式返回值為 true 時即返回 true，如為 false 再進行第二個表逹式判斷)
  ! 非 -->not-->取反

### 51.52.短路運算(邏輯中斷)

- 從左到右判斷，邏輯中斷會影響程序運行結果

- && 邏輯與(找 false)：
  表逹式 1 && 表逹式 2
  如果表逹式 1 為 true，則返回表逹式 2
  如果表逹式 1 為 false，則返回表逹式 1(表逹式 2 不會再進行判斷)
- || 邏輯或(找 true)：
  表逹式 1 || 表逹式 2
  如果表逹式 1 為 true，則返回表逹式 1(表逹式 2 不會再進行判斷)

### 53.賦值運算符

- `num++ -->num = num + 1 `後自增 1
- `num += 2 -->num = num + 2` 每次自増 2
- `num += 5 -->num = num + 5` 每次自増 5
- `num \= 3 -->num = num \ 3`

### 54.運算符優先級

- () -> 一元運算符 -> 算術 -> 關係 -> 相等 -> 邏輯 -> 賦值 -> 逗號
- 一元運算符中的邏輯非優先級很高
- 邏輯''與''比邏輯''或''的優先級高

### 55.流程控制

1.  意義：控制代碼按照什麼結構順序執行
2.  種類：區分為順序結構、分支結構、循環結構
    - 順序結構：程序會按照代碼的先後順序，依次執行。
    - 分支結構：由上到下執行代碼過程中，根據不同的條件，執行不同的路徑代碼，而得到不同的結果。
    - if 語句，switch 語句-->根據不同的條件，執行不同的路徑代碼(執行代碼多選一的過程)，從而得到不同的結果

```js
if (條件表逹式) {
  執行語句;
}
```

// 條件為 true-->執行語句 條件為 false-->不執行語句，並跳出 if 執行後面的代碼

// 條件為 true-->執行語句 條件為 false-->不執行語句，並跳出 if 執行後面的代碼

### 59.if else 語句雙分支(二選一)

```javascript
if (條件表逹式){
	執行語句 1
} else{
 	執行語句 2
}
// 如果條件表逹式為 true，則執行語句 1，如為 false 則執行語句 2，在這個雙分支語句最終只能有一個語句被執行
```

### 60.潤年與平年判斷

能被 4 整除且不能整除 100 者為潤年，或能被 400 整除的就是潤年

```js
var year = prompt("請輸入判斷年份");
if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
  alert("你輸入的年份是潤年");
} else {
  alert("你輸入的年份是平年");
}
```

### 61.if else if(多分支語句)(多選 1)

多分支語句，就是利用多個條件來選擇不同的語句執行，為多選 1 的過程

```js
if (條件表逹式 1){
	執行語句 1
} else if(條件表逹式 2) {
	執行語句 2
} else if(條件表逹式 3) {
	執行語句 3
....
} else {
	執行語句 n
}
```

1. 如果條件表逹式 1 成立則執行語句 1，執行完畢後退出整個 if 分支語句
2. 如果條件表逹式 1 不成立時，則判斷條件表逹式 2，滿足則執行語句 2，以此類推
3. 如果所有條件均不滿足都不成立時，則執行 else 內的語句
4. <<注意>>
   - 多分支語句是多選 1，最後只能有一個語句被執行
   - else if 內的條件理論上可以任意多個的
   - else if 中間有個空格 4.最後使用 else 結束

### 63.三元表逹式(二選一)

- 語法結構：
  - `條件表逹式 ? 表逹式1 ： 表逹式2`
- 如果條件表逹式成立時，則返回表逹式 1 的值，否則返回表逹式 2 的值，意即為二選一的 if else 簡寫版
  最後將返回值賦值給一個變量即可。

### 64.數字補 0 案例

如果用戶輸入的數字小於 10，則在前面補 0，如果大於 10，則不補 0

`var time = prompt('用戶輸入的 0-59 數字：');`
`var result = time<10 ? '0'+time ： time;`

### 65.66.switch 語句(匹配選項)

也是多分支語句，可實現多選 1 效果

- 針對變量設置一系列的特定值選項時使用 switch 語句實現多選一。

- switch(轉換、開關)，case(選項)，主要利用表逹式的值和 case 後的值相匹配，如匹配成立，就執行 case 的語句，如果未匹配上，則繼續下面的 case 的值匹配，如果都没有匹配上則執行 default 內的語句

- 語法結構：

  ```js
  switch(表逹式){
  	case 值 1：
  	執行語句 1;
  	break; //退出語句
  case 值 2：
  	執行語句 2;
  	break;
  	...
  default：
  最後的語句;
   }
  ```

- 注意事項：

  - 初始化變量就是用`var` 聲明一個變量，通常作為計數器使用，只會執行 1 次。

  - 條件表逹式就是用來決定每次循環是否繼續執行(終止條件)。

  - 操作表逹式是每次循環最後執行的代碼，通常用來更新計數器變量(遞增或遞減)(計數器更新)

    ​ `for(var i = 0 ; i < 5 ; i++){ console.log('hello'); }`

- 執行過程：
  1. 首先執行計數器變量`var i=1`(初始化變量，只執行 1 次) i -> index
  2. 判斷 i 的值是否滿足`i<=100`條件，如果滿足條件，則執行循環體，不滿足條件則退出循環體
  3. 執行`i++`(自增)
  4. 第二輪接著執行判斷 i 的值是否滿足`i<=100`條件，如果滿足條件，則執行循環體，不滿足條件則退出循環體

### 73.斷點調試

F12-->source-->設置斷點-->更新-->F11 下一步

### 75.for 循環

重覆執行不同的代碼，因為有計數器變量 i 存在，每次循環值 i 都會變化

### 81.雙重 for 循環

```js
for (外層初始化變量; 外層條件表逹式; 外層操作表逹式) {
  for (內層初始化變量; 內層條件表逹式; 內層操作表逹式) {
    執行語句;
  }
}
```

- 將內層循環當作是外層循環的執行語句
- 外層循環循環一次，內層循環執行全部，外層循環控制行數，內層循環控制列數(\*個數)

### 86.for 循環小結

1.  for 循環可重復執行某些相同代碼。

2.  因為有計數器存在，for 循環可重復執行些許不同的代碼。

3.  for 循環可重復執行某些操作，ex：累加操作。

4.  雙重 for 循環，外層 for 循環執行循環一次，內層 for 循環執行全部

### 87.while

```javascript
初始化變量;
while (條件表逹式) {
  循環體;
  操作表逹式(更新計數器， 防止死循環);
}
```

當條件表逹式為 true 時執行循環體，否則退出循環，如無操作表逹式時，會使整個循環成為死循環

### 89.do while

do while 是 while 的變形，該循環會先執行一次循環體，然後再對條件表逹式進行判斷，如為 true 則重復執行循環體，否則退出循環

```js
初始化變量;
do {
  循環體;
  操作表逹式;
} while (條件表逹式);
```

do while 與 while 最大不同在於 do while 會先執行一次循環體再進行條件判斷，如果條件表達式結果為 true，則繼續執行循環體，否則退出循環體

### 91.循環小結

1. 三者之間可相互替代使用
2. 用來計次數與數字相關者，使用 for
3. 較複雜的條件判斷時使用 while 或 do while
4. while 和 do while 執行順序不同，while 先判斷後執行，do...while 先執行一次循環體，再判斷條件

### 92.continue

- continue 關鍵字，立即跳過本次循環(當前該次的循環)，繼續執行剩餘次數的循環
  EX：求 1~100 之間，除了能被 7 整除之外的整數和?

### 93.break

- break 關鍵字用於立即退出整個循環，剩餘的循環不再執行

### 94.標識符命名規範

- 變量的名稱一般使用名詞，函數的名稱使用動詞

### 97.數組 array

1. 定義：一組數據的集合，每個數據稱為元素，可存放任意數據類型的元素，將一組數據存儲在一個變量下的一種模式，相較以往一個變量只存一個值的情況，更廣泛應用。
2. 創建數組：
   - 使用 new 關鍵字創建數組：
     var 數組名 = new Array(); --> 創建一個空的數組
     var arr = new Array(2); --> 表示創建一個長度為 2 的新數組，內含 2 個空的數組元素
     var arr = new Array(2，3); --> 表示創建一個新數組，數組元素為 2，3
   - 使用數組字面量創建數組：
     var 數組名 = [] --> 元素之間以，逗號隔開，元素可以是任意數據類型
     var arr=[1，2，3，4] --> 創建數組並賦值稱為數組的初始化

### 98.獲取數組元素

- 格式： 數組名[索引號]，索引號從 0 開始

- 透過數組元素的索引值(從 0 開始) ex：cosole.log(arr[0])獲取 arr 數組索引值為 0 的值，如無該索引值，則會返回 undefined。

### 99.遍歷數組

- 所謂遍歷就是把數組中的每個元素從頭到尾都訪問一遍，就是獲取數組中所有元素，方法--利用 for 循環：

```js
for (var i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

i 為計數器，當索引值使用，索引值從 0 開始，所以 i=0， 數組長度 length=最大索引值+1 ，所以 `i< arr.length`，arr[i]表示數組元素中第 i 個元素

### 100.數組長度 length

- 數組長度`arr.length` 是數組的元素個數，可利用 `arr.length` 動態監測數組元素個數，`arr[i]`就是數組元素中第 i 個數組元素
- 數組索引號從 0 開始，最後一個元素的索引號是`arr.length-1`

### 102.求數組中的最大值

1. 先聲明一個保存最大元素的變量`max`，默認最大值可以取數組中的第一個元素
2. 遍歷數組，將數組中的每個元素與`max`作比較，如果數組元素大於` max`，就把這個元素存放到 `max`，否則繼續下一輪比較
3. 最後輸出 `max` 即可得到最大值

### 104. 新增數組元素

1. 透過修改 length 長度來實現數組擴展，如未賦值則為 undefined
2. 透過修改數組索引值方式，如要向數組最後一個位置添加一個元素時，可使用
   - 數組名[數組名.length]=值
   - 特別注意：不可以直接給數組名賦值，否則會覆蓋掉原數組元素。

### 105.利用 for 循環追加數組元素

1. 聲明一個空的數組 arr

2. 利用 for 循環中的計數器 i 作為數組元素存入

3. 因為數組的索引號是從 0 開始，因此計數器從 0 開始，但存入的數組元素要+1。

   ```javascript
   var arr = [];
   for (var i = 0; i < 100; i++) {
     arr[i] = i + 1; //不要直接給數組名直接賦值，否則會替換掉所有元素
   }
   ```

### 106.篩選數組方法 1

1. 先聲明一個新的數組`newArr`用來存放新的數據
2. 遍歷原來的數組，並找出大於等於 10 的元素
3. 將篩選出來的元素追加到新數組中，由於新數組的索引號從 0 開始可利用新的變量(j=0)將篩選出來的元素追加到新數組中

### 107.篩選數組方法 2

利用 `newArr.length`，由於`newArr`新數組的索引號從 0 開始，依次遞增，所以`newArr[newArr.length]=arr[i]`

```js
var arr=[2，4，33，222，3，32，44];
var newArr=[];
for (var i = 0 ; i < arr.length ; i++){
  if (arr[i] >= 10){
for (var i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

i 為計數器，當索引值使用，索引值從 0 開始，所以 i=0， 數組長度 length=最大索引值+1 ，所以 i< arr.length
arr[i]表示數組元素中第 i 個元素

### 108.數組去重(簡易版)

```js
var arr=[2，4，0，55，33，23，0，6];
var newArr=[];
for (var i = 0;i<arr.length;i++){
	if (arr[i] != 0){  //將數組中元素為0的元素去掉保留非0元素
	newArr[newArr.length]=arr[i];
	}
}
console.log(newArr);
```

### 109.翻轉數組：即是將數組元素的順序作一反過來存放

1.先聲明一個新數組 newArr

2.將舊數組中最後一個取出來(arr.length-1)，賦值給新數組索引號為 0 的元素(newArr.length)

3.依次採取遞減方法獲取

```javascript
var arr = [2， 5， 6， 7， 44， 3， 9];
var newArr = [];
for (var i = arr.length - 1; i >= 0; i--) {
  newArr(newArr.length) = arr[i];
}
console.log(newArr);
```

### 110.數組排序(冒泡排序)

- 一次比較兩個元素，如果順序錯誤就將順序作一交換位置
- 交換位置時需利用一個臨時變量

### 111.冒泡排序

- 是一種排序算法，把一系列的數據按照一定的順序進行排序顯示(由大到小或由小到大)
- 作用原理：一次比較兩個元素，如果順序錯誤，就將他們的順序交換，依次比較完後再比較第二輪，第三輪...等
  第一輪交換 4 次
  第二輪交換 3 次
  第三輪交換 2 次
  第四輪交換 1 次
- 結論：外層 for 循環處理輪數(5 個數字共需交換 4 輪)，內層 for 循環處理每輪交換的次數(就是數組長度-1)，但次數是從 0 開始，所以`arr.length-i-1`

```javascript
var arr = [5， 4， 3， 2， 1];
for (var i = 0; i <= arr.length - 1; i++) {
  //外層循環管輪數
  for (var j = 0; j <= arr.length - i - 1; j++) {
    //內層循環管每輪交換的次數
    if (arr[j] > arr[j + 1]) {
      //先判斷前後兩個數據的大小，假如第一個數大於第二個數時，則兩個數的位置交換
      var temp = arr[j]; //交換位置先聲明一個臨時變量，且將大的數賦值給臨時變量
      arr[j] = arr[j + 1]; //第二個數賦值給第一個數
      arr[j + 1] = temp; //再將臨時變量賦值給第二個數
    }
  }
}
```

### 114.函數概念

JS 中的函數就是將一段可被重復調用執行的代碼塊封裝起來，日後僅需調用該函數即可，使用函數的目的就是讓大量代碼可重復使用

### 115 函數使用

兩大步驟：1.聲明函數 2.調用函數 1.聲明函數方法：

```js
function 函數名() {
  函數體;
}
```

1.  使用 function 關鍵字聲明函數，全部小寫
2.  函數是為了做某件事情，函數名一般是動詞
3.  函數不調用自己不執行-->口訣 2.調用函數：函數名()
4.  函數封裝就好像是快遞打包，將一些具有功能的代碼塊打包到函數中，方便日後執行

### 117 函數參數：實現函數執行重復不同的代碼

函數的參數可以有，也可以没有，個數不限

1.  形參：形式上的參數，函數定義時傳遞的參數，類似聲明一個變量，準備接收實參傳過來的值(相當於賦值)，可看做是不用聲明的變量
2.  實參：實際的參數值，函數調用時把實際要參與計算或顯示的值傳遞給形參

```js
function 函數名(形參1，形參2...){
    js	代碼塊
}
    函數名(實參1，實參2...);
```

- 調用函數時，函數名(實參 1，實參 2...)
- 參數的作用：在函數內部某些值不固定時，可通過參數在調用函數時傳遞不同的值進去

### 118. 求任意兩個數的和

```js
function getSum1(num1，num2){
	console.log(num1+num2);
}
getSum1(3，5); //8
```

### 119. 函數參數個數匹配

1. 實參個數>形參個數-->多餘部份會被省略
2. 實參個數<形參個數-->形參可視為不用聲明的變量，如形參未賦值時結果是 undefined
   請注意形參個數=實參個數才對

### 120.函數返回值

1. 函數只是實現某種功能，最終的結果需要返回給函數的調用者，函數名()，而這是通過 return 來實現的

```js
function 函數名() {
  return 需要返回的結果;
}
函數名();
```

2. 函數只要遇到 return 時就會把後面的結果返回給函數的調用者，意即函數名()=return 後面的結果，我們可以將函數調用的執行結果賦值給一個變量保存起來，如需輸出，則僅需輸出該變量即可。

```js
function getSum(num1，num2){
	return num1+num2;
}
var result = getSum(10，20);
console.log(result);
```

### 121.利用函數求任意兩個數的最大值

```js
function getMax(num1，num2){
	if(num1>num2){
		return num1;
	} else {
		return num2;
	}
	return num1 > num2 ? num1 ： num2; //三元表逹式
}
console.log(getMax(3，5));
```

### 122.利用函數求數組的最大值

```js
function getArrMax(arr){
	var max = arr[0];
	for (var i = 1 ; i <= arr.length ; i++){
		max = arr[i];
	}
	return max;
}
var re = getArrMax([4，2，44，33，55，1，3]);
console.log(re); //實際開發中，經常使用一個變量來接收函數的返回結果，使用上會更簡單
```

### 123. 使用 return 注意事項

1. return 是終止函數，所以 return 後面的代碼不會被執行
2. return 只能返回一個值，如有逗號隔開多個值時，只會返回最後一個值
3. 如需多個值可考慮使用數組形式
4. 函數如果有 return，則返回 return 後面的值，如果没有 return 時，則會返回 undefined

### 124.break、continue、return 的區別

1. break：結束當前的循環體
2. continue：跳出本次循環，繼續執行下次循環
3. return：不僅可以退出循環，還可返回 return 後面的值，並退出整個函數

### 126.arguments 的使用

- 不確定有多少個參數傳遞時，可使用 arguments 來獲取

- arguments 是當前函數的一個內置對象，所有函數中都內建了一個 arguments 對象，`arguments`對象中存儲了傳遞所有實參。

- arguments 展示形式是一個偽數組(並不是真正意義上的數組)，因此可遍歷，特點：

  1. 具有數組的 length 屬性 `arguments.length`

  2. 按照索引方式儲存數據

  3. 但不具有真數組 push()、pop()等方法-->與一般數組不同之處

  4. 可依數組方式遍歷 arguments

  5. 只有函數才有 arguments 對象，且每個函數都內建 arguments 對象，如此，可以不用刻意定義相對的形參來接收實參所傳遞過來的值

     ```js
     function fn(){
     	for (var i = 0;i < arguments.length;i++){
     		console.log(arguments[i]);
     	}
     }
     fn(1，2，3，4，5，5);
     ```

### 127.arguments 的使用：

利用函數求任意個數的最大值

```js
function getMax(){
	var max=arguments[0];
	for (var i=1;i<arguments.length;i++){
		if(arguments[i]>max){
			max=arguments[i];
		}
	}
	return max;
}
console.log(getMax(1，2，3));
console.log(getMax(14，52，3，2，54));
console.log(getMax(13，1，2，33，22，542，122));
```

### 129.函數冒泡排序

利用函數封裝方式對數組冒泡排序

```js
function sort(arr){
	for (var i=0;i<arr.length-1;i++){
		for (var j=0;j<arr.lenth-i-1;j++){
			if (arr[j]>arr[j+1]){
					var temp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=temp;
			}
		}
	}
	return arr;
}
var arr1=sort([1，3，5，7，8]);
console.log(arr1);
var arr2=sort([11，23，445，27，38，21，334]);
console.log(arr2);
```

### 130.函數閏年判斷

利用函數封裝判斷是否是閏年，如果是閏年返回 true，如果是平年則返回 false

```js
function isYear(year) {
  var flag = false;
  if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
    flag = true; //如果滿足時返回true
  }
  return flag; //否則返回false
}
console.log(isYear(2000));
console.log(isYear(1999));
```

### 131.函數調用另外一個函數

- 因為每個函數都是獨立的代碼塊．用於完成特殊任務，因此經常會用到函數相互調用情況

### 132.用戶輸入年份，輸出當前年份 2 月份的天數

如果是閏年，則 2 月份是 29 天，如果是平年，則 2 月份是 28 天

### 133 函數兩種聲明方式

1. 函數聲明 function 函數名(){}-->利用 function 關鍵字自定義函數
2. 函數表逹式 var 變量名=function(){}
   - 使用匿名函數，並將其賦值給一個變量，變量裏面存的是值，而函數表逹式裏面存的昰函數。
   - 也可以傳遞參數。

### 135 .作用域

1. 就是代碼名字(變量)在某個範圍內起作用和效果，目的是為了提高程序邏輯的局部性，增強程序的可靠性，更重要的是減少命名衝突。
2. JS 的作用域(ES6)之前，區分為兩種：全局作用域、局部作用域。
3. 全局作用域：指整個 script 標籤內或單獨的 JS 文件中(外部 JS 文件引用時)。
4. 局部作用域(函數作用域)：指在函數內部使用，變量作用範圍只在函數內部起作用和效果。

### 136.變量作用域

1. 變量作用域：根據作用域的不同，區分為全局變量和局部變量

   - 全局變量：在全局作用域下的變量，在全局中均可使用，**但如果在函數內部，只有賦值，但未聲明的變量也會轉為全局變量**。
   - 局部變量：在局部作用域下的變量，只能在函數內部使用，**函數形參也可以視為局部變量** 。

2. 從執行效率來看全局變量和局部變量：
   - 全局變量只有在瀏覽器關閉時才會銷毀，比較佔記憶體資源。
   - 局部變量則是當函數執行完畢就會銷毀，比較節省記憶體資源。

### 137.塊級作用域

ES6 才有塊級作用域，使用{}括起來的範圍，**ES6 以前没有塊級作用域**

### 138.作用域鏈

1. 內部函數可以訪問外部函數的變量，採取的是鏈式查找方式來決定要取那個值，這種結構稱之為作用域鏈
2. 函數內部可以使用外部函數的變量或全局變量，由內可以往外找(**就近原則**)，但函數外部無法使用函數內部變量

### 141.預解析(變量提前聲明)

- JS 代碼是透過瀏覽器中的 JS 解析器(如 chrome v8 引擎)來執行，Js 解析器在解析 JS 代碼時分成兩步：預解析和依序執行代碼。
  1. 預解析：JS 引擎會把 JS 中所有的`var`和 `function` 提升到當前作用域的最前面。
  2. 代碼執行：按照代碼書寫順序從上往下執行 。
- 預解析分為變量預解析(變量提升)和函數預解析(函數提升)
  1. 變量提升就是把所有的變量聲明提升到當前作用域最前面，但不賦值。
  2. 函數提升就是把所有的函數聲明提升到當前作用域最前面，但不調用函數。
- 注意：以函數表逹式創建的函數無函數聲明提前功能，所以調用函數仍需寫在函數表逹式後面否則會報錯。
- `var a = b = c = 9;`相當於`var a = 9; b = 9 ;c = 9;`　-->　 b 和 c 是未聲明變量，直接賦值，視為全局變量，與集體聲明同時賦值不同`var a = 9，b = 9，c=9;`以逗號隔開，`var a=9; var b=9; var c=9;`

### 133.函數兩種聲明方式

1.  函數聲明：function 函數名(){}-->利用 function 關鍵字自定義函數
2.  函數表逹式：var 變量名=function(){}

- 使用匿名函數，並將其賦值給一個變量，裏面存的是值，而函數表逹式裏面存的昰函數
- 也可以傳遞參數。

### 135.作用域

1.  就是代碼名字(變量)在某個範圍內起作用和效果，目的是為了提高程序邏輯的局部性，增強程序的可靠性，更重要的是減少命名衝突
2.  JS 的作用域(ES6)之前：區分為兩種：全局作用域、局部作用域
    - 全局作用域：指整個 script 標籤內或單獨的 JS 文件中(外部 JS 文件引用時)
    - 局部作用域(函數作用域)：指在函數內部使用，變量作用範圍只在函數內部起作用和有效果。

### 136.變量作用域

1.  變量作用域：根據作用域的不同，區分為全局變量和局部變量

    - 全局變量：在全局作用域下的變量，在全局中均可使用，但如果在函數內部，只有賦值，但未聲明的變量也會轉為全局變量
    - 局部變量：在局部作用域下的變量，只能在函數內部使用，函數形參也可以視為局部變量

2.  從執行效率來看全局變量和局部變量：
    - 全局變量只有在瀏覽器關閉時才會銷毀，比較佔記憶體資源
    - 局部變量則是當函數執行完畢就會銷毀，比較節省記憶體資源

### 137.JS 塊級作用域

ES6 才有塊級作用域，使用{}括起來的範圍，ES6 以前没有

### 138.作用域鏈

- 內部函數可以訪問外部函數的變量，採取的是鏈式查找方式來決定要取那個值，這種結構稱之為作用域鏈
- 函數內部可以使用外部函數的變量或全局變量，由內可以往外找(就近原則)，但函數外部無法使用函數內部變量

### 141.預解析(變量提前聲明)

1.  JS 代碼是透過瀏覽器中的 JS 解析器(如 chrome v8 引擎)來執行，
2.  Js 解析器在解析 JS 代碼時分成兩步：預解析和依序執行代碼

- 預解析：JS 引擎會把 JS 中所有的 var 和 function 提升到當前作用域的最前面
- 代碼執行：按照代碼書寫順序從上往下執行
- 預解析分為變量預解析(變量提升)和函數預解析(函數提升)
  - 變量提升就是把所有的變量聲明提升到當前作用域最前面，但不賦值
  - 函數提升就是把所有的函數聲明提升到當前作用域最前面，但不調用函數

3.  注意：以函數表逹式創建的函數無函數聲明提前功能，所以調用函數仍需寫在函數表逹式後面否則會報錯
4.  var a = b = c = 9;相當於 var a = 9; b = 9 ;c = 9;-->b 和 c 是未聲明變量，直接賦值，視為全局變量
    與集體聲明同時賦值不同：var a = 9，b = 9，c=9;以逗號隔開，var a=9; var b=9; var c=9;

### 144.JS 對象(object)

- 對象是一個具體的事物，在 JS 中對象是一組無序的相關屬性和方法的集合，由屬性和方法組成。
- 屬性：事件的特徵，在對象中用屬性來表示(常用名詞)--外表
- 方法：事件的行為，在對象中用方法來表示(常用動詞)--功能
- 保存一個值時，可使用變量，保存多個值時，可使用數組，但要保存一個人的完整信息?使用對象來保存表逹，結構更清晰更強大。

### 145.創建對象(object)的三種方式

- 利用字面量創建對象
- 利用 new Object 創建對象
- 利用構造函數創建對象
  - 對象字面量：使用{} var obj={}創建一個空對象; {}內包含表逹這個對象的屬性和方法

    ```js
    var obj={
    	name：'王大'， //屬性
    	age：18，
    	sex：'男'，
    	 sayhello：function(){ //匿名函數-->方法
    		console.log()
    	}
    }
    ```

    - 屬性或方法採用 屬性名：屬性值 方式表示
    - 多個屬性或方法間使用逗號隔開 \
    - 方法時冒號後面跟著一個匿名函數

  - 使用對象
    - 調用對象的屬性： 對象名.屬性名 .理解為"的"
    - 另一種調用對象屬性： 對象名['屬性名']
    - 調用對象的方法： 對象名.方法名()-->注意要加上()

### 146.變量、屬性、函數、方法總結

- 變量和屬性的相同點：均是用來存儲數據的，不同點：
  - 變量：單獨聲明並賦值，使用時直接寫變量名，單獨存在
  - 屬性：在對象中不需聲明，使用時需使用 對象名.屬性
- 函數和方法相同點：均是用來實現某種功能，做某件事
  - 函數是單獨聲明單獨存在的，且調用時使用 函數名()
  - 方法(對象中的函數稱為方法，用來描述對象的行為和功能)則是在對象中，不需要聲明，調用時使用 對象名.方法()

### 147.使用 new 創建對象

1.  var obj= new Object();創建一個空的對象 <--"O"要大寫

2.  新增屬性和方法：

    ```js
    obj.name = "王八";
    obj.age = 18;
    obj.sayHi = function () {
      函數體;
    };
    ```

3.  說明

    - 利用 等號= 賦值方式添加對象的屬性和方法
    - 每個屬性和方法以分號結束
    - 調用時使用對象名.屬性名或對象名['屬性名']或對象.方法名()

### 148.使用構造函數創建對象

為什麼需要使用構造函數創建對象，因為前面兩種方式一次只能創建一個對象，其中如果有很多屬性和方法相同時，只能使用複製，因此可使用函數的方法，將這些重複相同的代碼，封裝成構造函數，構造函數中封裝的是對象，就是將對象中一些公共的屬性和方法抽取出來封裝到函數裏面。

### 149.構造函數()：

是一種特殊的函數，主要用來初始化對象，也就是為對象成員變量賦予初始值，它總是與 new 運算符一起使用

1.  聲明構造函數語法：

```js
function 構造函數名() {
  //首字母大寫
  this.屬性 = 值;
  this.方法 = function () {};
}
```

2.  調用時：
    new 構造函數名();

3.  規範：
    - 構造函數名首字母大寫
    - 構造函數不需要 return 就可以返回結果
    - 調用構造函數時需使用 new 關鍵字
    - 調用構造函數時同時創建一個新對象
    - 屬性和方法前面必須添加 this

### 151.構造函數和對象

1.  對象 ex：劉德華，"特指"其中的某一個具體的事物，調用函數時返回時同時創建一個新對象

2.  構造函數 ex：明星，是抽象了對象的公共部份，封裝到函數內，它"泛指"的是某一大類
3.  利用構造函數創建對象的過程稱為對象的實例化
    可以使用 instanceof 檢查一個對象是否是某一大類的實例，如果是則返回 true，否則返回 false
4.  語法： 對象 instanceof 構造函數
5.  注意：所有的對象均是 Object 的後代，所以任何對象和 Object 在 instanceof 檢查時都會返回 true

### 152.構造函數中 new 關鍵字

new 關鍵字執行過程四步曲：
1.new 構造函數可在記憶體中創建一個空的對象 -->生了一個寶寶
2.this 就會指向剛創建的空對象 -->這個寶寶需是親生的 this 指向 3.執行構造函數裏面的代碼，給這個空對象添加屬性和方法-->教孩子讀書寫字(加屬性和方法) 4.返回這個新對象(所以構造函數裏面不需要 return) -->回報父母(返回新對象)
\*\*\*this 的使用情況：(尚硅谷) 1.當以函數形式調用時，this 是 window 2.當以方法的形式調用時，this 指向的是函數調用的對象 3.當以構造函數的形式調用時，this 就是新創建的對象(實例)

### 153 遍歷對象屬性==

for..in 語句：用於遍歷對象
for ( var 變量 in 對象){  
 console.log(變量) -->可遍歷屬性名
console.log(obj[變量])-->可遍歷屬性值，不用加引號
}
使用 for in 中的變量，通常使用 k 或 key

### 154 .對象小結==

1.對象可以讓代碼結構更清晰 2.對象屬於複雜的數據類型 object 3.對象的本質就是一組無序的相關屬性和方法的集合 4.構造函數泛指某一大類，ex：蘋果，不管是紅色蘋果或是綠色蘋果，均統稱為蘋果 5.對象實例特指某一個具體的事物，可利用構造函數創建新的對象稱之為對象的實例化 6.使用 for...in 語句來遍歷對象的屬性進行循環操作

### 156.內建對象

JS 對象區分三種：自定義對象、內建對象(DOM)(前面兩種屬於 ECMAScript)、瀏覽器對象(BOM)-->JS 獨有 - 內建對象乃是 JS 語言自帶的一些對象，提供開發者直接使用，內含一些基本或常用的屬性和方法，可用來執行某些功能和效果
最大優點是幚助程序員快速開發，所以應存感恩的心學習。

### 157.查閱文檔

- MDN-查說明看功能，如何使用語法，是否需參數，返回值意義和類型，再透過 demo 進行測試一下

- Javascript 參考手冊

### 158.Math 數學對象==

不是構造函數，直接使用屬性和方法
(1)PI(圓周率)屬性： console.log(Math.PI);
(2)Math.max()求最大值方法： console.log(Math.max(1，3，9))
(3)Math.round()方法：四捨五入，.5 較特殊，它往大值取，-1.5-->-1
(4)Math.floor()：向下取整，往最小的取值，無條件捨去
(5)Math.ceil()：向上取整，往最大的取值，無條件進位
161.random()隨機數方法，不用加參數，隨機抽奬、隨機點名 1.返回一個隨機 0~1 的小數(0<=x<1)，不用加參數 2.可以得到一個兩數之間的隨機整數，包括前後兩個數在內(公式參考 MDN)
Math.floor(Math.random() \* (max - min + 1)) + min; 162.猜數字遊戲

### 163.日期對象(Date)==

1. 是一個構造函數，需使用 new 來調用並創建日期對象，未加參數時代表系統當前日期時間
   var date=new Date();
   console.log(date);
2. 參數常用寫法：數字型 2019，8，8 或字符串型'2019-08-08 08：08：08'或者'2019/10/10'
3. getMonth()月份部份必須加 1，getDay()星期則返回的是 0~6，0 表星期日，1 表星期一...可使用數組方式獲取 4.如要在時間前面補 0 的話可利用下列程序：
   h = h < 10 ? '0' + h ： h;

### 12.獲取時間戳(總毫秒數)

特性：值不會重複 1.總毫秒數是當前系統時間距離 1970 年 1 月 1 日所經歷的總毫秒數，數字不會重複 2.四種獲取方法：
(1)valueOf()：需先實例化
(2)getTime()：需先實例化
(3)var date=+new Date()-->使用+new 常用，不加參數時返回當前時間的總毫秒數，加參數就是用戶輸入時間的總毫秒數
(4)Date.now()：H5 新增，獲取距離 1970.7.1 日的總毫秒數，可以不用實例化 14.倒數計時：輸入的時間減去現在的時間就是剩餘時間，利用時間戳來完成，再轉換為天.時.分.秒
總毫秒數/1000=總秒數
d = parseInt(總秒數/60/60/24);
h = parseInt(總秒數/60/60%24);
m = parseInt(總秒數/60%60);
s = parseInt(總秒數%60);

### 16.數組對象:檢測是否為數組

1. instanceof 運算符，用來檢測對象的形態 ex： arr instanceof Array; obj instanceof Object;
2. Array.isArray(檢測值) H5 新增的方法，IE9 以上版本支持

### 17.添加數組元素

1. push(參數 1，參數 2...)在數組的末尾添加一個或多個數組新元素，並返回新數組長度
2. unshift(參數 1，參數 2...)在數組的開頭添加一個或多個數組新元素，並返回新數組長度

### 18.刪除數組元素

1. pop()用於刪除數組最後一個元素，返回值為刪除那個元素，不用參數
2. shift()用於刪除數組開頭一個元素，返回值為刪除那個元素，不用參數

### 20.數組排序

1. reverse()翻轉數組排序
2. sort()數組排序(冒泡排序)-->1，10，11，12，2，20，21 會先依個位數，十位數先排序，解決方法如下：
sort(function(a，b){
return a-b; //升序排列
return b-a; //降序排列
})

### 21.獲取數組元素索引

1. indexOf(數組元素)，從前面開始查找指定的元素並返回第一個元素的索引號，元素如有重覆時只返回第 1 個滿足條件的
索引號，如找不到該元素時返回-1
2. lastIndexOf(數組元素)，從後面往前查找元素並返回元素的索引號，如找不到時返回-1

### 22.數組去重

重要案例，加強練習
核心原理：遍歷舊數組，再以舊數組去查詢新數組，如果該元素在新數組不存在時，則添加，如果已存在時，則不添加。
檢查該元素在新數組中是否存在的方法就是利用 indexOf(數組元素)，如果值等於-1 時表示不存在，則 push()，否則不添加

### 23.數組轉換為字符串

1. toString()：轉換後以逗號隔開
2. join('分隔符')：未加參數時，默認使用逗號隔開，可以使用其他符號隔開 ex：arr.join('-')或 arr.join('&')

### 24.字符串對象

對象才有屬性和方法，引用(複雜)數據類型才有屬性和方法，基本數據類型為何有 length 屬性? -基本包裝類型：就是將基本數據類型包裝成為複雜數據類型
var str='coca';
console.log(str.length);//4  
 -->基本數據類型為何有 length 屬性?因為它們執行了下列程序
(1)把基本數據類型包裝為引用數據類型
var temp=new String('coca');
(2)把臨時變量的值賦值給 str
str=temp;
(3)銷毀這個臨時變量
temp=null;
JS 提供三個特殊的引用類型：String，Number，Boolean

### 25.字符串的不可變性

因為字符串的不可變性，指的是裏面的值不可變，雖然看上去改變內容了，但其實是地址變了，內存中又新開闢了
一個內存空間，然後將新值放入，原來的字符串仍存在未消失，所以不要大量的拼接字符串

### 26.根據字符返回位置

字符串所有的方法，都不會修改字符串本身(字符串是不可變的)，操作完成會返回一個新的字符串
查詢字符串所在位置之索引值
(1)indexOf('要查找的字符'，[開始查找的索引值]) 起始位置是索引值，從起始位置往後查找
(2)lastIndexOf()從後面往前找

### 28.根據位置(索引值)返回字符

1. charAt(索引值)：根據位置(索引值)返回字符，可用來遍歷字符串
2. str[index]：H5 新增的，獲取指定位置的字符
3. charCodeAt(index)：會返回相應索引的字符 ASCII 值，目的：判斷用戶按下了那一個鍵 A：65 a：97 29.判斷一個字符串'abcoefsalkjldfajfglggrie'中出現次數最多的字符，並統計其字數
核心算法：利用 charAt()遍歷這個字符串
把每個字符存儲給對象，如果對象没有該屬性，就等於 1，如果已存在該屬性時，就+1
遍歷對象，得到最大值和該字符

### 31.字符串方法

1. concat('字符串 1'，'字符串 2'...)：用於連接兩個或多個字符串，作字符串拼接，實務上大多使用+
2. substr(截取的起始位置 start，截取長度 length)：截取字符串

### 32.替換字符、轉換為數組

1. replace('被替換的字符'，'替換為的字符')：它只會替換第一個字符
2. split('分隔符')：取決於字符串中以何種分隔符隔開，將字符串轉換為數組==>join()把數組轉換為字符串，

### 34.數據類型總結

- 基本數據類型：在存儲時變量中存儲的是值本身，因此又稱為值類型，包含五種 Number、String、Boolean、undefined，null
- 複雜數據類型：在存儲時變量中存儲的是地址(引用)，因此又稱為引用數據類型，Object、Array、Date 等
- 基本數據類型存於棧內存，存放的是值，
- 複雜數據類型存於堆內存，首先在棧內存放地址(16 進制)，然後這個地址指向堆內的數據
- null-->返回的是一個空對象 object
- 如變量打算存儲為對象，但暫時還没想好放啥，此時可先賦值為 null

### 整理

- typeof value(變量) --> 檢查某個值(變量)的數據類型 -->返回值為 string number boolean
- instanceof 語法： 對象 instanceof 構造函數 --> 檢查一個對象是否是某一大類的實例 -->返回值為 true 或 false
  instanceof 運算符，用來檢測對象的形態
- indexOf 語法１：indexOf('要查找的字符'，[開始查找的索引值])　——＞是一個方法：用來查找字符或數組
  　　　 　　 語法２：indexOf(數組元素)，從前面開始查找指定的元素並返回第一個元素的索引號

### 35.基本數據類型傳參

函數的形參可視為一個變量，當把一個值類型變量作為參數傳給函數的形參時，其實是把變量在棧內存中的值複
製一份給形參，因此在方法內部對形參做任何修改，均不影響外部變量
```js 
function fn(a){
  a++;
  console.log(a); //11
}
var x =10;
fn(x);
console.log(x); //10
```
### 36.引用數據類型傳參

函數的形參可視為一個變量，當我們把引用類型變量傳給形參時，其實是把變量在拡空間中保存的堆地址複製
一份傳給了形參，形參和實參保存的是同一個堆地址，所以操作的同一個對象
```js
function Person(name){
  this.name=name;
}
function f1(x){
  console.log(x.name); //劉德華
  x.name='張學友';
  console.log(x.name); //張學友
}
var p=new Person('劉德華');
console.log(p.name); //劉德華  
f1(p);
console.log(p.name); //張學友
```
