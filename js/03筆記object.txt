46object=========================================================================================
基本數據類型的不足：
　 1.基本數據類型均是單一值,ex:"hello" 123 true ,值與值之間没有任何聯繫。
  2.如果使用基本數據類型的數據,所創建的變量均是獨立的,不能成為一個整體。
object對象(物件):屬於一種複合數據類型,在對象中可保存多個不同數據類型的屬性,如同一個容器、袋子一般
分類:
 1.內建對象:由ES標準中定義的對象,在任何ES的實現中均可使用  ex: Math String Number function.....
 2.宿主對象：由JS的運行環境提供的對象,目前主要指瀏覽器提供的對象 ex：BOM DOM
 3.自定義對象:由開發人員自行創建的對象-->三者之中最難的

47創建對象方式1:使用構造函數========================================================================
  創建對象(物件object)：
   -使用new關鍵字調用的函數,是構造函數constructor:專門用來創建自定義對象的函數
  var obj = new Object();  //使用typeof檢查時會返回類型為object
  在對象中保存的值稱為屬性,
   1.向對象添加屬性
		-語法:對象.屬性名=屬性值;
    ex:  obj.name = "王大海";
         obj.sex = "男";
         obj.age = 18;....... name sex age 均為obj的屬性
   2.讀取對象中的屬性：
		-語法：對象.屬性名  ex: consloe.log(obj.name);如果讀取對象中没有該屬性時,不會報錯而是返回undefined
   3.修改對象的屬性值:
		-語法:對象.屬性名=新值
   4.刪除對象屬性:  
		-語法:delete 對象.屬性名

48屬性名和屬性值==================================================================================
  1.屬性名:對象的屬性名不強制要求遵守標識符規範,任何名字均可使用,但儘量按照標識符規範命名,如果使用特殊的屬
          性名,不可使用.的方式操作,改用中括號-->[""]
        語法: 對象["屬性名"] = 屬性值  讀取時也需使用這種方式
        使用中括號[]模式操作屬性,更加靈活,例如可在[]中直接傳遞一個變量,如此變量值多少就會讀取那個屬性
  2.屬性值:JS對象的屬性值可以是任意的數據類型,甚至也可以是一個對象
      in 運算符-->用來檢查某個對象中是否含有指定的屬性時使用in運算符,如有則返回true,如無則返回false
      語法: "屬性名" in 對象 ex:console.log("test" in obj);

49基本和引用數據類型===============================================================================
  數據類型區分兩大類:
  一.基本數據類型:String Number Boolean Null Undefined
  二.引用數據類型:Object 
  1.js的變量均是保存棧內存中。 基本數據類型儲存的是值,而引用數據類型儲存的是引用地址。
  2.基本數據類型的值直接在(棧內存Stack)中存儲,值與值之間是獨立存在,修改一個變量的值不會影響其他變量的值
  3.對象是保存到(堆內存Heap),每創建一個新的對象,就會在堆內存中開闢出一個新的空間,而變量保存的是對象的內存地址(對象的引用),
          如果兩個變量保存的是同一個對象引用,當其中一個變量修改屬性時,另一個也會受到影響
  4.當比較兩個基本數據類型的值時,就是直接比較值是否相等。
  5.當比較兩個引用數據類型時,它是比較對象的內存地址,如果兩個對象一模一樣,但地址不同時,它也會返回false,意即屬性名和屬性值不作比較
  	如同DNA一般,雙胞胎雖DNA可能完全相同,但他們代表兩個人(對象)

50創建對象方式2:使用對象字面量=====================================================================
  創建對象的方式:
  1.使用構造函數 var obj= new Object()
  2.使用對象字面量,ex var obj={} ,或可在創建對象時,直接指定對象的屬性,屬性名可加引號或不加,建議不加,但
    使用特殊名字時,則要加引號
    語法: {屬性名1:屬性值1,屬性名2:屬性值2,屬性名3:屬性值3...}名和值之間使用:連結,多個屬性之間以,逗號隔開,最後
                  一個已無其他屬性了,就不用再加,逗號
    ex:  var obj = {name:"王大同",sex:"男",age:20};-->創建對象時同時指定屬性 or
         var obj = {
             name:"王大同",
             sex:"男",
             age:20,
             test:{name:"沙和尚"}-->屬性值也可以是對象或函數
            };

51函數簡介========================================================================================
  1.函數也是對象之一,具有普通對象的功能(可添加屬性...),但函數功能較強大,還可以封裝一些功能(代碼),在需要時可
		執行這些功能(代碼)--調用函數()
  2.使用typeof檢查函數的數據類型時會返回function
  創建函數方式:
  1.使用構建函數創建一個函數:(很少用此方法)-->1.使用new關鍵字 2.Function首字母大寫
    var fun = new Function()  //可將要封裝的代碼以字符串形式傳遞給構造函數,封裝到函數中的代碼不會立即執行
		,只有在調用時才執行
    **調用函數語法：函數對象()  調用函數時,封裝的代碼會按照順序執行
  2.使用 "函數聲明" 創建一個函數：
    語法: function 函數名([形參1,形參2....形參n]){
              語句...
          }
    調用: 函數名()  
  3.使用 "函數表逹式" 創建一個匿名函數,並將匿名函數對象賦值給一個變量
    var 變量 = function([形參1,形參2....形參n]){
          語句...
        }; <---如同宣告變量一般,最後記得加上;
    ex: var fun3 = function(){    //聲明一個匿名函數
        console.log("這是我的第二個函數");
        };
      調用 fun3()

52函數的參數========================================================================================
可在函數的()中指定一個或多個形參(形式參數,未指定值),多個形參之間以逗號,隔開,聲明形參就相當於函數內部聲明對應的變量,但並未賦值,在調用函數時,可在()中指定實參(實際參數),實參將會賦值給函數中對應的形參,調用時瀏覽器不會檢查實參類型,因此注意可能會接收到非法參數,必要時需對實參類型進行檢查,調用時瀏覽器也不會檢查實參的數量,多餘的實參不會被賦值,實參少於形參者,則没有對應的形參,將產生undefined結果
  ***函數之實參可以是任意數據類型***

53函數返回值=========================================================================================
  使用return來設置函數返回值:
  語法: return 值    
  1.return後的值將會作為函數的執行結果,因此,可定義一個變量來接收執行結果;
  2.在函數中return後的語句都不會執行	-->函數已將執行結果返回,所以return後的語句都不會再被執行
  3.return語句後不加任何值,或者不寫return時,則函數調用結果將返回undefined
  4.return後的值可以是任何類型(包含運算式、判斷式...)
54================================================================================================
  1.實參可以昰任意的數據類型,也可以是對象,當參數過多時,可將參數封裝到一個對象中,再通過對象傳遞
  2.實參也可以是一個函數
55函數返回值與break ==============================================================
	使用break可以退出當前的循環
	使用continue可以跳過當次循環
	使用return可以結束整個函數
返回值可以任意的數據類型,包括運算式,判斷式....也可以是一個對象和函數-->對象能做的事,函數也都能做	

57Js方法==============================	==============================================================
	1.對象的屬性值可以是任何數據類型,也可以函數
	2.如果函數作為對象的屬性保存時,則稱這個函數是這個對象的方法,
		調用函數則稱為調用這個對象名的方法,但是它只是名稱上的區別,没有本質上的差別
	==枚舉對象中的屬性==
	使用for...in 語句
	語法: for(var 變量 in 對象){
		}
	for...in語句  對象中有幾個屬性,循環體就會執行幾次,每次執行時,會將對象中的一個屬性的名字賦值給變量
	每次執行時,會將對象中的一個屬性的名字賦值給變量,這個變量就是屬性名,如要取得屬性值是則可以用
	-->對象[變量]

58全局作用域(scope)=========================================================================================
	 作用域指一個變量的作用範圍,區分為兩種:全局作用域及局部作用域
	 1.全局作用域:
	 	a.直接編寫在script標籤中的JS代碼,都在全局作用域
	 	b.在頁面打開時創建,在頁面關閉時銷毀
	 	c.在全局作用域中有一個全局對象window,它代表的是一個瀏覽器的窗口,它由瀏覽器創建,可直接使用ex:console.log(window);
	 	d.在全局作用域中所創建的任何變量均會作為window對象的屬性保存
	 	e.創建的函數均會作為window對象的方法保存
	 	f.全局作用域中的變量都是全局變量,在頁面的任意地方均可以訪問的到
	 	
		===變量的聲明提前===
	 	1.使用var關鍵字聲明的變量,會在所有的代碼執行之前被聲明(但尚未賦值),但聲明變量時不使用var關鍵字,則變量不會被聲明提前,會報錯
	 	
	 	===函數的聲明提前===
	 	1.函數聲明會被提前創建:使用函聲明方式創建的函數 function 函數名(){},它會在所有的代碼執行前就被創建,因此可以在函數聲明前調用函數
	 	2.函數表逹式不會被提前創建:使用函數表逹式創建的函數 var fun=function(){},它不會被聲明提前,所以不能在聲明前調用函數
	 
59函數作用域(局域作用域)===============================================================================
	1.調用函數時創建函數作用域,函數執行完畢後,	函數作用域銷毀
	2.每調用一次函數就會創建一個新的函數作用域,他們之間是互相獨立的
	3.在函數作用域中可以訪問到全局作用域的變量,在全局作用域中無法訪問到函數作用域的變量
	4.當在函數作用域操作一個變量時,它會先在自身作用域中尋找,如果有就直接使用,如果没有則向上一級作用域尋找,直到找到全局作用域,如果全
		局作用域中也没有找到,則會報錯
	5.在函數中如要直接使用全局變量,可以使用window對象
	6.在函數作用域中也有聲明提前的特性,使用var關鍵字聲明的變量,會在函數中所有的代碼執行前被聲明
	7.函數聲明也會在函數中所有代碼執行前被聲明
	8.在函數中,不使用var聲明的變量都會成為全局變量
	9.定義形參就相當於在函數作用域中聲明了一個變量

60debug===========================================================================================	