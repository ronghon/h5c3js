61this===================================================================================================================
	1.瀏覽器在調用函數時每次都會向函數內部傳遞一個隠含參數this,它指向的是函數執行的上下文對象
	2.根據函數調用方式不同,this會指向不同的對象
		- 以函數的形式調用時,this永遠都是window
		- 以方法的形式調用時,this就是調用方法的對象
		
63使用工廠方法(Factory Method)創建對象========================================================================================
	==利用工廠方法使一個類別的實例化延遲到其子類別==
	- 透過工廠方法可大批量的創建對象
		1.創建一個新的對象-->使用new關鍵字 new Object()
		2.向對象中添加屬性
		3.將新的對象返回-->用return返回值
	- 使用工廠方法創建的對象,使用的構造函數都是屬於object類型,會導致無法區分多種不同類型的對象

	==構造函數==
	  構造函數,專門用來創建自定義對象,它也是一個普通函數,創建方式與普通函數没有區別,不同的是
	  1.構造函數習慣上首字母大寫
	  2.調用方式的不同,普通函數是直接調用,而構造函數需在調用時加上new關鍵字
	  3.構造函數執行流程:
		a.調用時會立即創建一個新的對象
		b.將新建的對象設置為函數中的this,在構造函數中可以使用this來引用新建的對象
		c.逐行執行函數中的代碼
		d.將新建的對象作為返回值返回,不用設定return返回值
	  4.使用同一個構造函數創建的對象,我們稱為一類對象,也將一個構造函數稱為一個類,
		透過構造函數所創建的對象,稱為該類(構造函數)的實例
	  5.使用instanceof 可以檢查對象是否是一個類的實例==>判斷實例的類型
		語法: 對象 instanceof 構造函數  ==> 如果是,則返回true,如果不是,則返回false
	- 所有的對象都是Object的後代,所以任何對象使用instanceof檢查時都會返回true

	==this使用情況==
		1.當以函數的形式調用時,this永遠都是window
		2.當以方法的形式調用時,誰調用方法this就是誰
		3.當以構造函數的形式調用時,this就是新創建的那個對象

	65構造函數修改=========================================================================================
		1.在構造函數中為每個對象添加fun方法,
		2.構造函數每執行乙次就會創建一個新的fun方法,也就是所有實例的fun方法是唯一且獨立的,但這些方法其實都是一模一樣的,
		3.需將它轉化為所有對象共享的方法,將函數定義在全局作用域中,並將函數名賦予給fun
	
	66原型對象=============================================================================================
		將fun方法在全局作用域中定義，產生另外的問題：1.污染了全局作用域的命名空間2.多人開發中較不安全==>新概念"原型"
		==原型對象==
			原型prototype
			我們所創建的每一個函數,瀏覽器都會向函數中添加一個屬性prototype,這個屬性對應著一個對象,而將這個對象稱為原型對象
			如果函數作為普通函數調用時,此一prototype没有任何作用,但當函數以構造函數的形式調用時,它所創建的對象中都會有一個
			隠含的屬性指向該構造函數的原型對象,我們可以通過__proto__來查詢該屬性,