61this===================================================================================================================
	1.瀏覽器在調用函數時每次都會向函數內部傳遞一個隠含參數this,它指向的是函數執行的上下文對象
	2.根據函數調用方式不同,this會指向不同的對象
		- 以函數的形式調用時,this永遠都是window
		- 以方法的形式調用時,this就是調用方法的對象
		
63使用工廠方法(Factory Method)創建對象========================================================================================
	==利用工廠方法使一個類別的實例化延遲到其子類別==
	- 透過工廠方法可大批量的創建對象
		1.創建一個新的對象-->使用new關鍵字 new Object()
		2.向對象中添加屬性
		3.將新的對象返回-->用return返回值
	- 使用工廠方法創建的對象,使用的構造函數都是屬於object類型,會導致無法區分多種不同類型的對象

	==構造函數==
	  構造函數,專門用來創建自定義對象,它也是一個普通函數,創建方式與普通函數没有區別,不同的是
	  1.構造函數習慣上首字母大寫
	  2.調用方式的不同,普通函數是直接調用,而構造函數需在調用時加上new關鍵字
	  3.構造函數執行流程:
			a.調用時會立即創建一個新的對象
			b.將新建的對象設置為函數中的this,在構造函數中可以使用this來引用新建的對象
			c.逐行執行函數中的代碼
			d.將新建的對象作為返回值返回,不用設定return返回值
	  4.使用同一個構造函數創建的對象,我們稱為一類對象,也將一個構造函數稱為一個類,
		  透過構造函數所創建的對象,稱為該類(構造函數)的實例
	  5.使用instanceof 可以檢查對象是否是一個類的實例==>判斷實例的類型
		語法: 對象 instanceof 構造函數  ==> 如果是,則返回true,如果不是,則返回false
	- 所有的對象都是Object的後代,所以任何對象使用instanceof檢查時都會返回true

	==this使用情況==
		1.當以函數的形式調用時,this永遠都是window
		2.當以方法的形式調用時,誰調用方法this就是誰
		3.當以構造函數的形式調用時,this就是新創建的那個對象

	65構造函數修改=========================================================================================
		1.在構造函數中為每個對象添加fun方法,
		2.構造函數每執行乙次就會創建一個新的fun方法,也就是所有實例的fun方法是唯一且獨立的,但這些方法其實都是一模一樣的,
		3.需將它轉化為所有對象共享的方法,將函數定義在全局作用域中,並將函數名賦予給fun
	
	66原型對象=============================================================================================
		將fun方法在全局作用域中定義，產生另外的問題：1.污染了全局作用域的命名空間2.多人開發中較不安全==>新概念"原型"
		==原型對象==
			原型對象屬性prototype,創建函數時由瀏覽器自動向函數中添加prototype和地址並指向原型對象
			我們所創建的每一個函數,瀏覽器都會向函數中添加一個屬性prototype,這個屬性對應著一個對象,而將這個對象稱為原型對象
			如果函數作為普通函數調用時,此一prototype没有任何作用,但當函數以構造函數的形式調用時,它所創建的對象中都會有一個
			隠含的屬性指向該構造函數的原型對象,我們可以通過__proto__來查詢該屬性,原型對象就相當於一個公共的區域,所有同一個類的實例
			都可以訪問到這個原型對象,因此可以將對象中共有的內容,統一設置到原型對象中
			當我們訪對象的一個屬性或方法時,它會先在對象自身中尋找,如有,則直接使用,如無,則會去原型對象中尋找,如果找到,則直接使用
			結論:以後創建構函數時,可將這些對象共有的屬性和方法,統一添加到構造函數的原型對象中,如此就不用分別為每一個對象添加,也不會影
			響到全局作用域,就可以使每個對象都具有這些屬性和方法
		67.
			- 使用in檢查對象中是否含有某個屬性時,如果對象中没有但原型中有,也會返回true
			- 檢查自身對象中是否含有某個屬性,使用hasOwnProperty("屬性名"),使用該方法只有當對象中含有該屬性時,才會返回true
			- 原型對象也是對象,所以它也有原型,當使用一個對象的屬性或方法時,會先在自身中尋找,自身中如果有,則直接使用,如果没有,則去原型
			  對象中尋找,如果原型對象中有,則使用,如果没有則去原型的原型中尋找,直到找到Object對象的原型,Object對象的原型没有原型,如果
				在Object中依然没有找到,則返回undefined
		68.toString()
			- 當我們直接在頁面中打印一個對象時,事實上是輸出對象的toString()方法的返回值
			- 
		69.垃圾回收(GC)
			- 當一個對象没有任何的變量或屬性對它進行引用,此時我們將永遠無法操作該對象,此時這種對象就是一個垃圾,這種對象過多就會占用大量
			  的內存空間,導致程序運行變慢,所以需針對這垃圾進行清理。
			- 在JS中擁有自動的垃圾回收機制,會自動將這些垃圾對象從內存中銷毀,我們不需要也不能進行垃圾回收的操作
			- 我們需要做的只是將不再使用的對象設置為null即可。